var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});

// package.json
var version = "2.2.2";

// src/structures/BaseManager.ts
var BaseManager = class {
  constructor() {
    this.meta = {
      current: 0,
      total: 0,
      count: 0,
      perPage: 0,
      totalPages: 0
    };
  }
  getQueryOptions() {
    return {
      filters: this.FILTERS,
      sorts: this.SORTS,
      includes: this.INCLUDES
    };
  }
  async getFetchAll(...options) {
    const opts = options[options.length - 1] || {
      page: 1
    };
    let data = await this.fetch(...options);
    if (this.meta.totalPages > 1) {
      for (let i = 2; i <= this.meta.totalPages; i++) {
        opts.page = i;
        let page = await this.fetch(opts);
        data.update(page);
      }
    }
    return data;
  }
};
__name(BaseManager, "BaseManager");

// src/structures/Dict.ts
var _Dict = class extends Map {
  constructor() {
    super(...arguments);
    this._limit = 0;
  }
  get limit() {
    return this._limit;
  }
  setLimit(amount) {
    if (this._limit)
      throw new Error("Cannot override a set limit.");
    this._limit = amount < 0 ? 0 : amount;
  }
  isLimited() {
    return !!this._limit && super.size === this._limit;
  }
  set(key, value) {
    if (this.isLimited())
      throw new Error(`Dict has reached its limit (${this._limit})`);
    return super.set(key, value);
  }
  some(fn) {
    for (const [k, v] of this)
      if (fn(v, k, this))
        return true;
    return false;
  }
  every(fn) {
    for (const [k, v] of this)
      if (!fn(v, k, this))
        return false;
    return true;
  }
  hasAny(...keys) {
    return keys.some((k) => super.has(k));
  }
  hasAll(...keys) {
    return keys.every((k) => super.has(k));
  }
  first(amount) {
    const v = [...super.values()];
    if (amount === void 0)
      return v[0];
    const s = v.splice(0, amount);
    return s.length === 1 ? s[0] : s;
  }
  firstKey(amount) {
    const k = [...super.keys()];
    if (amount === void 0)
      return k[0];
    const s = k.splice(0, amount);
    return s.length === 1 ? s[0] : s;
  }
  last(amount) {
    const v = [...super.values()];
    if (amount === void 0)
      return v[v.length - 1];
    const s = v.slice(-amount);
    return s.length === 1 ? s[0] : s;
  }
  lastKey(amount) {
    const k = [...super.keys()];
    if (amount === void 0)
      return k[k.length - 1];
    const s = k.slice(-amount);
    return s.length === 1 ? s[0] : s;
  }
  random(amount) {
    const v = [...super.values()];
    if (amount === void 0)
      return v[Math.floor(Math.random() * v.length)];
    const s = [];
    for (let i = 0; i < amount; i++)
      s.push(v[Math.floor(Math.random() * v.length)]);
    return s.length === 1 ? s[0] : s;
  }
  randomKey(amount) {
    const k = [...super.keys()];
    if (amount === void 0)
      return k[Math.floor(Math.random() * k.length)];
    const s = [];
    for (let i = 0; i < amount; i++)
      s.push(k[Math.floor(Math.random() * k.length)]);
    return s.length === 1 ? s[0] : s;
  }
  map(fn) {
    const res = [];
    for (const [k, v] of this)
      res.push(fn(v, k, this));
    return res;
  }
  filter(fn) {
    const res = new _Dict();
    for (const [k, v] of this)
      if (fn(v, k, this))
        res.set(k, v);
    return res;
  }
  find(fn) {
    for (const [k, v] of this)
      if (fn(v, k, this))
        return v;
    return void 0;
  }
  sweep(fn) {
    let res = 0;
    for (const [k, v] of this)
      if (fn(v, k, this))
        super.delete(k) && res++;
    return res;
  }
  part(fn) {
    const pass = new _Dict();
    const fail = new _Dict();
    for (const [k, v] of this)
      if (fn(v, k, this))
        pass.set(k, v);
      else
        fail.set(k, v);
    return [pass, fail];
  }
  reduce(fn, acc) {
    for (const [k, v] of this)
      acc = fn(v, k, this);
    return acc;
  }
  join(...dict) {
    const res = this.clone();
    for (const d of dict)
      for (const [k, v] of d)
        res.set(k, v);
    return res;
  }
  difference(dict) {
    const res = new _Dict();
    for (const [k, v] of this)
      if (!dict.has(k))
        res.set(k, v);
    for (const [k, v] of dict)
      if (!super.has(k))
        res.set(k, v);
    return res;
  }
  update(dict) {
    for (const [k, v] of dict)
      this.set(k, v);
  }
  clone() {
    return new _Dict(super.entries());
  }
};
var Dict = _Dict;
__name(Dict, "Dict");
"constructor";

// src/structures/Errors.ts
var PteroAPIError = class extends Error {
  constructor(data) {
    const fmt = data.errors.map((e) => `- ${e.status}: ${e.detail || "No details provided"}`).join("\n");
    super("\n" + fmt);
    this.codes = data.errors.map((e) => e.code);
    this.meta = data.errors.map((e) => e.meta).filter(Boolean);
  }
};
__name(PteroAPIError, "PteroAPIError");
var RequestError = class extends Error {
};
__name(RequestError, "RequestError");
var ValidationError = class extends Error {
  constructor(...args) {
    switch (args.length) {
      case 3:
        super(
          `Failed to validate ${args[0]}: expected ${args[1]}; got ${args[2]}`
        );
        break;
      case 2:
        break;
      case 1:
        super(`Validation: ${args[0]}`);
        break;
      default:
        super("Validation check failed.");
        break;
    }
  }
};
__name(ValidationError, "ValidationError");
var WebSocketError = class extends Error {
};
__name(WebSocketError, "WebSocketError");

// src/util/caseConv.ts
function camelCase(str) {
  let res = "";
  let next = false;
  str.split("").forEach((c) => {
    if (next) {
      next = false;
      res += c.toUpperCase();
    } else if (c === "_") {
      next = true;
    } else {
      res += c;
    }
  });
  return res;
}
__name(camelCase, "camelCase");
function toCamelCase(obj, options = {}) {
  if (typeof obj !== "object")
    return obj;
  const parsed = {};
  if (Array.isArray(obj)) {
    return obj.map((i) => toCamelCase(i));
  }
  for (let [k, v] of Object.entries(obj)) {
    if (options.ignore?.includes(k))
      continue;
    if (options.map?.[k])
      k = options.map[k];
    if (options.cast?.[k]) {
      try {
        const cls = options.cast[k];
        v = new cls(v);
      } catch {
        v = String(v);
      }
    }
    if (Array.isArray(v)) {
      v = v.map((i) => toCamelCase(i));
    } else if (typeof v === "object" && !!v) {
      v = toCamelCase(v);
    }
    parsed[camelCase(k)] = v;
  }
  return parsed;
}
__name(toCamelCase, "toCamelCase");
function snakeCase(str) {
  let res = "";
  const isUpper = /* @__PURE__ */ __name((c) => "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("").includes(c), "isUpper");
  str.split("").forEach((c) => {
    if (isUpper(c))
      res += "_";
    res += c.toLowerCase();
  });
  return res;
}
__name(snakeCase, "snakeCase");
function toSnakeCase(obj, options = {}) {
  if (typeof obj !== "object")
    return obj;
  const parsed = {};
  if (Array.isArray(obj)) {
    return obj.map((i) => toSnakeCase(i));
  }
  for (let [k, v] of Object.entries(obj)) {
    if (options.ignore?.includes(k))
      continue;
    if (options.map?.[k])
      k = options.map[k];
    if (options.cast?.[k]) {
      try {
        const cls = options.cast[k];
        v = new cls(v);
      } catch {
        v = String(v);
      }
    }
    if (Array.isArray(v)) {
      v = v.map((i) => toSnakeCase(i));
    } else if (typeof v === "object" && !!v) {
      v = toSnakeCase(v);
    }
    parsed[snakeCase(k)] = v;
  }
  return parsed;
}
__name(toSnakeCase, "toSnakeCase");
var caseConv_default = {
  toCamelCase,
  toSnakeCase
};

// src/application/endpoints.ts
var endpoints_default = {
  users: {
    main: "/users",
    get: (u) => `/users/${u}`,
    ext: (u) => `/users/external/${u}`
  },
  nodes: {
    main: "/nodes",
    get: (n) => `/nodes/${n}`,
    deploy: "/nodes/deployable",
    config: (n) => `/nodes/${n}/configuration`,
    allocations: {
      main: (n) => `/nodes/${n}/allocations`,
      get: (n, a) => `/nodes/${n}/allocations/${a}`
    }
  },
  servers: {
    main: "/servers",
    get: (s) => `/servers/${s}`,
    ext: (s) => `/servers/external/${s}`,
    details: (s) => `/servers/${s}/details`,
    build: (s) => `/servers/${s}/build`,
    startup: (s) => `/servers/${s}/startup`,
    suspend: (s) => `/servers/${s}/suspend`,
    unsuspend: (s) => `/servers/${s}/unsuspend`,
    reinstall: (s) => `/servers/${s}/reinstall`,
    databases: {
      main: (s) => `/servers/${s}/databases`,
      get: (s, id) => `/servers/${s}/databases/${id}`,
      reset: (s, id) => `/servers/${s}/databases/${id}/reset-password`
    }
  },
  locations: {
    main: "/locations",
    get: (l) => `/locations/${l}`
  },
  nests: {
    main: "/nests",
    get: (n) => `/nests/${n}`,
    eggs: {
      main: (n) => `/nests/${n}/eggs`,
      get: (n, e) => `/nests/${n}/eggs/${e}`
    }
  }
};

// src/application/ApplicationDatabaseManager.ts
var ApplicationDatabaseManager = class extends BaseManager {
  constructor(client, serverId) {
    super();
    this.client = client;
    this.cache = new Dict();
    this.serverId = serverId;
  }
  get FILTERS() {
    return Object.freeze([]);
  }
  get INCLUDES() {
    return Object.freeze(["host", "password"]);
  }
  get SORTS() {
    return Object.freeze([]);
  }
  _patch(data) {
    if (data.data) {
      const res = new Dict();
      for (let o of data.data) {
        const d2 = caseConv_default.toCamelCase(
          o.attributes
        );
      }
      this.cache.update(res);
      return res;
    }
    const d = caseConv_default.toCamelCase(data.attributes);
    this.cache.set(d.id, d);
    return d;
  }
  async fetch(op, ops = {}) {
    let path;
    switch (typeof op) {
      case "number": {
        if (!ops.force && this.cache.has(op))
          return this.cache.get(op);
        path = endpoints_default.servers.databases.get(this.serverId, op);
        break;
      }
      case "undefined":
      case "object": {
        path = endpoints_default.servers.databases.main(this.serverId);
        if (op)
          ops = op;
        break;
      }
      default:
        throw new ValidationError(
          `expected database id or fetch options; got ${typeof op}`
        );
    }
    const data = await this.client.requests.get(path, ops, null, this);
    return this._patch(data);
  }
  async create(database, remote, host) {
    if (!/^[0-9%.]{1,15}$/.test(remote))
      throw new ValidationError(
        "remote did not pass the required validation: /^[0-9%.]{1,15}$/"
      );
    const data = await this.client.requests.post(
      endpoints_default.servers.databases.main(this.serverId),
      { database, remote, host }
    );
    return this._patch(data);
  }
  async resetPasword(id) {
    await this.client.requests.post(
      endpoints_default.servers.databases.reset(this.serverId, id)
    );
  }
  async delete(id) {
    await this.client.requests.delete(
      endpoints_default.servers.databases.get(this.serverId, id)
    );
    this.cache.delete(id);
  }
};
__name(ApplicationDatabaseManager, "ApplicationDatabaseManager");

// src/structures/ApplicationServer.ts
var ApplicationServer = class {
  constructor(client, data) {
    this.client = client;
    this.databases = new ApplicationDatabaseManager(client, data.id);
    this.id = data.id;
    this.uuid = data.uuid;
    this.identifier = data.identifier;
    this.createdAt = new Date(data.created_at);
    this.createdTimestamp = this.createdAt.getTime();
    this._patch(data);
  }
  _patch(data) {
    if ("external_id" in data)
      this.externalId = data.external_id;
    if ("name" in data)
      this.name = data.name;
    if ("description" in data)
      this.description = data.description || void 0;
    if ("status" in data)
      this.status = data.status;
    if ("suspended" in data)
      this.suspended = data.suspended;
    if ("limits" in data)
      this.limits = caseConv_default.toCamelCase(data.limits);
    if ("feature_limits" in data)
      this.featureLimits = data.feature_limits;
    if ("user" in data)
      this.ownerId = data.user;
    if ("node" in data)
      this.nodeId = data.node;
    if ("allocation" in data)
      this.allocation = data.allocation;
    if ("nest" in data)
      this.nest = data.nest;
    if ("egg" in data)
      this.egg = data.egg;
    if ("container" in data) {
      this.container = caseConv_default.toCamelCase(data.container, {
        ignore: ["environment"]
      });
      this.container.environment = data.container.environment;
      this.container.installed = !!this.container.installed;
    }
    if ("relationships" in data) {
      this.owner = "user" in data.relationships ? this.client.users.resolve(data) : void 0;
      this.node = "node" in data.relationships ? this.client.nodes.resolve(data) : void 0;
    }
  }
  get panelURL() {
    return `${this.client.domain}/server/${this.identifier}`;
  }
  get adminURL() {
    return `${this.client.domain}/admin/servers/view/${this.id}`;
  }
  async fetchOwner() {
    if (this.owner)
      return this.owner;
    const user = await this.client.users.fetch(this.ownerId, {
      force: true
    });
    this.owner = user;
    return user;
  }
  async updateDetails(options) {
    const data = await this.client.servers.updateDetails(this.id, options);
    this._patch(data.toJSON());
    return this;
  }
  async updateBuild(options) {
    const data = await this.client.servers.updateBuild(this.id, options);
    this._patch(data);
    return this;
  }
  async updateStartup(options) {
    const data = await this.client.servers.updateStartup(this.id, options);
    this._patch(data);
    return this;
  }
  async suspend() {
    await this.client.servers.suspend(this.id);
  }
  async unsuspend() {
    await this.client.servers.unsuspend(this.id);
  }
  async reinstall() {
    await this.client.servers.reinstall(this.id);
  }
  toJSON() {
    return caseConv_default.toSnakeCase(this, {
      ignore: ["client", "user", "node"],
      map: { ownerId: "user", nodeId: "node" }
    });
  }
  toString() {
    return this.name;
  }
};
__name(ApplicationServer, "ApplicationServer");

// src/application/ApplicationServerManager.ts
var ApplicationServerManager = class extends BaseManager {
  constructor(client) {
    super();
    this.client = client;
    this.cache = new Dict();
    this.meta = {
      current: 0,
      total: 0,
      count: 0,
      perPage: 0,
      totalPages: 0
    };
  }
  get FILTERS() {
    return Object.freeze([
      "name",
      "uuid",
      "uuidShort",
      "externalId",
      "image"
    ]);
  }
  get INCLUDES() {
    return Object.freeze([
      "allocations",
      "user",
      "subusers",
      "nest",
      "egg",
      "variables",
      "location",
      "node",
      "databases"
    ]);
  }
  get SORTS() {
    return Object.freeze(["id", "-id", "uuid", "-uuid"]);
  }
  get defaultLimits() {
    return {
      memory: 128,
      swap: 0,
      disk: 512,
      io: 500,
      cpu: 100,
      threads: null
    };
  }
  get defaultFeatureLimits() {
    return {
      allocations: 1,
      databases: 1,
      backups: 1
    };
  }
  _patch(data) {
    if (data?.meta?.pagination) {
      this.meta = caseConv_default.toCamelCase(data.meta.pagination, {
        ignore: ["current_page"]
      });
      this.meta.current = data.meta.pagination.current_page;
    }
    if (data.data) {
      const res = new Dict();
      for (let o of data.data) {
        const s2 = new ApplicationServer(this.client, o.attributes);
        res.set(s2.id, s2);
      }
      if (this.client.options.servers.cache)
        this.cache.update(res);
      return res;
    }
    const s = new ApplicationServer(this.client, data.attributes);
    if (this.client.options.servers.cache)
      this.cache.set(s.id, s);
    return s;
  }
  resolve(obj) {
    if (obj instanceof ApplicationServer)
      return obj;
    if (typeof obj === "number")
      return this.cache.get(obj);
    if (typeof obj === "string")
      return this.cache.find((s) => s.name === obj);
    if (obj.relationships?.servers)
      return this._patch(obj.relationships.servers);
    return void 0;
  }
  adminURLFor(id) {
    return `${this.client.domain}/admin/servers/view/${id}`;
  }
  panelURLFor(id) {
    return `${this.client.domain}/server/${id}`;
  }
  async fetch(op, ops = {}) {
    let path;
    switch (typeof op) {
      case "number": {
        if (!ops.force && this.cache.has(op))
          return this.cache.get(op);
        path = endpoints_default.servers.get(op);
        break;
      }
      case "string": {
        if (!ops.force) {
          const u = this.cache.find((u2) => u2.externalId === op);
          if (u)
            return u;
        }
        path = endpoints_default.servers.ext(op);
        break;
      }
      case "undefined":
      case "object": {
        path = endpoints_default.servers.main;
        if (op)
          ops = op;
        break;
      }
      default:
        throw new ValidationError(
          `expected server id, external id or fetch options; got ${typeof op}`
        );
    }
    const data = await this.client.requests.get(path, ops, null, this);
    return this._patch(data);
  }
  fetchAll(options) {
    return this.getFetchAll(options);
  }
  async query(entity, options) {
    if (!options.sort && !options.filter)
      throw new ValidationError("Sort or filter is required.");
    if (options.filter === "identifier")
      options.filter = "uuidShort";
    if (options.filter === "externalId")
      options.filter = "external_id";
    const payload = {};
    if (options.filter)
      payload.filter = [options.filter, entity];
    if (options.sort)
      payload.sort = options.sort;
    const data = await this.client.requests.get(
      endpoints_default.servers.main,
      payload,
      null,
      this
    );
    return this._patch(data);
  }
  async create(options) {
    options.limits = Object.assign(
      this.defaultLimits,
      options.limits || {}
    );
    options.featureLimits = Object.assign(
      this.defaultFeatureLimits,
      options.featureLimits || {}
    );
    const payload = caseConv_default.toSnakeCase(options, {
      ignore: ["environment"]
    });
    payload.environment = options.environment;
    const data = await this.client.requests.post(
      endpoints_default.servers.main,
      payload
    );
    return this._patch(data);
  }
  async updateDetails(id, options) {
    if (!Object.keys(options).length)
      throw new ValidationError("Too few options to update the server.");
    const server = await this.fetch(id, { force: true });
    options.name ||= server.name;
    options.owner ??= server.ownerId;
    options.externalId ||= server.externalId;
    options.description ||= server.description;
    const payload = caseConv_default.toSnakeCase(options, {
      map: { owner: "user" }
    });
    const data = await this.client.requests.patch(
      endpoints_default.servers.details(id),
      payload
    );
    return this._patch(data);
  }
  async updateBuild(id, options) {
    if (!Object.keys(options).length)
      throw new ValidationError("Too few options to update the server.");
    const server = await this.fetch(id, { force: true });
    options.limits = Object.assign(server.limits, options.limits);
    options.featureLimits = Object.assign(
      server.featureLimits,
      options.featureLimits
    );
    options.allocation ??= server.allocation;
    const data = await this.client.requests.patch(
      endpoints_default.servers.build(id),
      caseConv_default.toSnakeCase(options)
    );
    return this._patch(data);
  }
  async updateStartup(id, options) {
    if (!Object.keys(options).length)
      throw new ValidationError("Too few options to update the server.");
    const server = await this.fetch(id, { force: true });
    options.egg ??= server.egg;
    options.environment ||= server.container.environment;
    options.image ||= server.container.image;
    options.skipScripts ??= false;
    options.startup ||= server.container.startupCommand;
    const payload = caseConv_default.toSnakeCase(options, {
      ignore: ["environment"]
    });
    payload.environment = options.environment;
    const data = await this.client.requests.patch(
      endpoints_default.servers.startup(id),
      payload
    );
    return this._patch(data);
  }
  suspend(id) {
    return this.client.requests.post(endpoints_default.servers.suspend(id));
  }
  unsuspend(id) {
    return this.client.requests.post(endpoints_default.servers.unsuspend(id));
  }
  reinstall(id) {
    return this.client.requests.post(endpoints_default.servers.reinstall(id));
  }
  async delete(id, force = false) {
    await this.client.requests.delete(
      endpoints_default.servers.get(id) + (force ? "/force" : "")
    );
    this.cache.delete(id);
  }
};
__name(ApplicationServerManager, "ApplicationServerManager");

// src/application/NestEggsManager.ts
var NestEggsManager = class extends BaseManager {
  constructor(client) {
    super();
    this.client = client;
    this.cache = new Dict();
  }
  get FILTERS() {
    return Object.freeze([]);
  }
  get INCLUDES() {
    return Object.freeze([
      "nest",
      "servers",
      "config",
      "script",
      "variables"
    ]);
  }
  get SORTS() {
    return Object.freeze([]);
  }
  _patch(data) {
    if (data?.data) {
      const res = new Dict();
      for (let o of data.data) {
        let e2 = caseConv_default.toCamelCase(o.attributes);
        e2.createdAt = new Date(e2.createdAt);
        e2.updatedAt &&= new Date(e2.updatedAt);
        res.set(e2.id, e2);
      }
      this.cache.update(res);
      return res;
    }
    let e = caseConv_default.toCamelCase(data.attributes);
    e.createdAt = new Date(e.createdAt);
    e.updatedAt &&= new Date(e.updatedAt);
    this.cache.set(e.id, e);
    return e;
  }
  adminURLFor(id) {
    return `${this.client.domain}/admin/nests/egg/${id}`;
  }
  async fetch(nest, op1, op2 = {}) {
    let path = endpoints_default.nests.eggs.main(nest);
    if (typeof op1 === "number") {
      if (!op2.force && this.cache.has(op1))
        return this.cache.get(op1);
      path = endpoints_default.nests.eggs.get(nest, op1);
    } else {
      if (op1)
        op2 = op1;
    }
    const data = await this.client.requests.get(path, op2, null, this);
    return this._patch(data);
  }
};
__name(NestEggsManager, "NestEggsManager");

// src/application/NestManager.ts
var NestManager = class extends BaseManager {
  constructor(client) {
    super();
    this.client = client;
    this.cache = new Dict();
    this.eggs = new NestEggsManager(client);
    this.meta = {
      current: 0,
      total: 0,
      count: 0,
      perPage: 0,
      totalPages: 0
    };
  }
  get FILTERS() {
    return Object.freeze([]);
  }
  get INCLUDES() {
    return Object.freeze(["eggs", "servers"]);
  }
  get SORTS() {
    return Object.freeze([]);
  }
  _patch(data) {
    if (data?.meta?.pagination) {
      this.meta = caseConv_default.toCamelCase(data.meta.pagination, {
        ignore: ["current_page"]
      });
      this.meta.current = data.meta.pagination.current_page;
    }
    if (data?.data) {
      const res = new Dict();
      for (let o of data.data) {
        const n2 = caseConv_default.toCamelCase(o.attributes);
        n2.createdAt = new Date(n2.createdAt);
        n2.updatedAt &&= new Date(n2.updatedAt);
        res.set(n2.id, n2);
      }
      if (this.client.options.nests.cache)
        this.cache.update(res);
      return res;
    }
    const n = caseConv_default.toCamelCase(data.attributes);
    n.createdAt = new Date(n.createdAt);
    n.updatedAt &&= new Date(n.updatedAt);
    if (this.client.options.nodes.cache)
      this.cache.set(n.id, n);
    return n;
  }
  adminURLFor(id) {
    return `${this.client.domain}/admin/nests/view/${id}`;
  }
  async fetch(op, include = []) {
    let path = endpoints_default.nests.main;
    if (typeof op === "number") {
      path = endpoints_default.nests.get(op);
    } else {
      include.push(...op || []);
    }
    const data = await this.client.requests.get(
      path,
      { include },
      null,
      this
    );
    return this._patch(data);
  }
};
__name(NestManager, "NestManager");

// src/application/NodeAllocationManager.ts
var NodeAllocationManager = class extends BaseManager {
  constructor(client) {
    super();
    this.client = client;
    this.cache = new Dict();
    this.meta = {
      current: 0,
      total: 0,
      count: 0,
      perPage: 0,
      totalPages: 0
    };
  }
  get FILTERS() {
    return Object.freeze([]);
  }
  get INCLUDES() {
    return Object.freeze(["node", "server"]);
  }
  get SORTS() {
    return Object.freeze([]);
  }
  _patch(node, data) {
    if (data?.meta?.pagination) {
      this.meta = caseConv_default.toCamelCase(data.meta.pagination, {
        ignore: ["current_page"]
      });
      this.meta.current = data.meta.pagination.current_page;
    }
    const res = new Dict();
    for (let o of data.data) {
      const a = caseConv_default.toCamelCase(o.attributes);
      res.set(a.id, a);
    }
    const all = (this.cache.get(node) || new Dict()).join(res);
    this.cache.set(node, all);
    return res;
  }
  adminURLFor(id) {
    return `${this.client.domain}/admin/nodes/view/${id}/allocation`;
  }
  async fetch(node, options = {}) {
    if (!options.force) {
      const a = this.cache.get(node);
      if (a)
        return Promise.resolve(a);
    }
    const data = await this.client.requests.get(
      endpoints_default.nodes.allocations.main(node),
      options,
      null,
      this
    );
    return this._patch(node, data);
  }
  fetchAll(node, options) {
    return this.getFetchAll(node, options);
  }
  async fetchAvailable(node, single) {
    const all = await this.fetchAll(node, { force: true });
    return single ? all.filter((a) => !a.assigned).first() : all.filter((a) => !a.assigned);
  }
  async create(node, ip, ports) {
    if (!ports.every((p) => typeof p === "string"))
      throw new TypeError(
        "Allocation ports must be a string integer or string range."
      );
    for (const port of ports) {
      if (!port.includes("-"))
        continue;
      const [_start, _stop] = port.split("-");
      const start = Number(_start), stop = Number(_stop);
      if (start > stop)
        throw new RangeError("Start cannot be greater than stop.");
      if (start <= 1024 || stop > 65535)
        throw new RangeError(
          "Port range must be between 1024 and 65535."
        );
      if (stop - start > 1e3)
        throw new RangeError("Maximum port range exceeded (1000).");
    }
    await this.client.requests.post(
      endpoints_default.nodes.allocations.main(node),
      { ip, ports }
    );
  }
  async delete(node, id) {
    await this.client.requests.delete(
      endpoints_default.nodes.allocations.get(node, id)
    );
    this.cache.get(node)?.delete(id);
  }
};
__name(NodeAllocationManager, "NodeAllocationManager");

// src/application/NodeLocationManager.ts
var NodeLocationManager = class extends BaseManager {
  constructor(client) {
    super();
    this.client = client;
    this.cache = new Dict();
    this.meta = {
      current: 0,
      total: 0,
      count: 0,
      perPage: 0,
      totalPages: 0
    };
  }
  get FILTERS() {
    return Object.freeze(["short", "long"]);
  }
  get INCLUDES() {
    return Object.freeze(["nodes", "servers"]);
  }
  get SORTS() {
    return Object.freeze([]);
  }
  _patch(data) {
    if (data?.meta?.pagination) {
      this.meta = caseConv_default.toCamelCase(data.meta.pagination, {
        ignore: ["current_page"]
      });
      this.meta.current = data.meta.pagination.current_page;
    }
    if (data?.data) {
      const res = new Dict();
      for (let o of data.data) {
        const n = caseConv_default.toCamelCase(o.attributes);
        n.createdAt = new Date(n.createdAt);
        n.updatedAt &&= new Date(n.updatedAt);
        res.set(n.id, n);
      }
      if (this.client.options.locations.cache)
        this.cache.update(res);
      return res;
    }
    const loc = caseConv_default.toCamelCase(data.attributes);
    loc.createdAt = new Date(loc.createdAt);
    loc.updatedAt &&= new Date(loc.updatedAt);
    if (this.client.options.locations.cache)
      this.cache.set(data.id, loc);
    return loc;
  }
  resolve(obj) {
    if (typeof obj === "number")
      return this.cache.get(obj);
    if (typeof obj === "string")
      return this.cache.find((o) => o.short === obj || o.long === obj);
    if (obj.relationships?.location?.attributes)
      return this._patch(obj.relationships.location);
    return void 0;
  }
  adminURLFor(id) {
    return `${this.client.domain}/admin/locations/view/${id}`;
  }
  async fetch(op, ops = {}) {
    let path = endpoints_default.locations.main;
    if (typeof op === "number") {
      if (!ops.force && this.cache.has(op))
        return this.cache.get(op);
      path = endpoints_default.locations.get(op);
    } else {
      if (op)
        ops = op;
    }
    const data = await this.client.requests.get(path, ops, null, this);
    return this._patch(data);
  }
  fetchAll(options) {
    return this.getFetchAll(options);
  }
  async query(entity, options) {
    if (!options.sort && !options.filter)
      throw new ValidationError("Sort or filter is required.");
    const payload = {};
    if (options.filter)
      payload.filter = [options.filter, entity];
    if (options.sort)
      payload.sort = options.sort;
    const data = await this.client.requests.get(
      endpoints_default.locations.main,
      payload,
      null,
      this
    );
    return this._patch(data);
  }
  async create(short, long) {
    const data = await this.client.requests.post(endpoints_default.locations.main, {
      short,
      long
    });
    return this._patch(data);
  }
  async update(id, options) {
    if (!options.short && !options.long)
      throw new ValidationError(
        "Either short or long is required to update the location"
      );
    const data = await this.client.requests.patch(
      endpoints_default.locations.get(id),
      options
    );
    return this._patch(data);
  }
  async delete(id) {
    await this.client.requests.delete(endpoints_default.locations.get(id));
    this.cache.delete(id);
  }
};
__name(NodeLocationManager, "NodeLocationManager");

// src/structures/Node.ts
var Node = class {
  constructor(client, data) {
    this.client = client;
    this.id = data.id;
    this.uuid = data.uuid;
    this.createdAt = new Date(data.created_at);
    this._patch(data);
  }
  _patch(data) {
    if ("public" in data)
      this.public = data.public;
    if ("name" in data)
      this.name = data.name;
    if ("description" in data)
      this.description = data.description || void 0;
    if ("location_id" in data)
      this.locationId = data.location_id;
    if ("fqdn" in data)
      this.fqdn = data.fqdn;
    if ("scheme" in data)
      this.scheme = data.scheme;
    if ("behind_proxy" in data)
      this.behindProxy = data.behind_proxy;
    if ("maintenance_mode" in data)
      this.maintenance = data.maintenance_mode;
    if ("memory" in data)
      this.memory = data.memory;
    if ("memory_overallocate" in data)
      this.overallocatedMemory = data.memory_overallocate;
    if ("disk" in data)
      this.disk = data.disk;
    if ("disk_overallocate" in data)
      this.overallocatedDisk = data.disk_overallocate;
    if ("upload_size" in data)
      this.uploadSize = data.upload_size;
    if (!this.daemon)
      this.daemon = {};
    if ("daemon_listen" in data)
      this.daemon.listening = data.daemon_listen;
    if ("daemon_sftp" in data)
      this.daemon.sftp = data.daemon_sftp;
    if ("daemon_base" in data)
      this.daemon.base = data.daemon_base;
  }
  get adminURL() {
    return `${this.client.domain}/admin/nodes/view/${this.id}`;
  }
  async getConfig() {
    return await this.client.nodes.getConfig(this.id);
  }
  async update(options) {
    const data = await this.client.nodes.update(this.id, options);
    this._patch(data.toJSON());
    return this;
  }
  toJSON() {
    return caseConv_default.toSnakeCase(this, {
      ignore: ["client", "location", "servers"],
      map: {
        maintainance: "maintenance_mode",
        overallocatedMemory: "memory_overallocate",
        overallocatedDisk: "disk_overallocate"
      }
    });
  }
  toString() {
    return this.name;
  }
};
__name(Node, "Node");

// src/application/NodeManager.ts
var NodeManager = class extends BaseManager {
  constructor(client) {
    super();
    this.client = client;
    this.cache = new Dict();
    this.meta = {
      current: 0,
      total: 0,
      count: 0,
      perPage: 0,
      totalPages: 0
    };
  }
  get FILTERS() {
    return Object.freeze(["uuid", "name", "fqdn", "daemon_token_id"]);
  }
  get INCLUDES() {
    return Object.freeze(["allocations", "location", "servers"]);
  }
  get SORTS() {
    return Object.freeze(["id", "uuid", "memory", "disk"]);
  }
  _patch(data) {
    if (data?.meta?.pagination) {
      this.meta = caseConv_default.toCamelCase(data.meta.pagination, {
        ignore: ["current_page"]
      });
      this.meta.current = data.meta.pagination.current_page;
    }
    if (data?.data) {
      const res = new Dict();
      for (const obj of data.data) {
        const s = new Node(this.client, obj.attributes);
        res.set(s.id, s);
      }
      if (this.client.options.servers.cache)
        this.cache.update(res);
      return res;
    }
    const n = new Node(this.client, data.attributes);
    if (this.client.options.nodes.cache)
      this.cache.set(n.id, n);
    return n;
  }
  resolve(obj) {
    if (obj instanceof Node)
      return obj;
    if (typeof obj === "number")
      return this.cache.get(obj);
    if (typeof obj === "string")
      return this.cache.find((n) => n.name === obj);
    if (obj.relationships?.node)
      return this._patch(obj.relationships.node);
    return void 0;
  }
  adminURLFor(id) {
    return `${this.client.domain}/admin/nodes/view/${id}`;
  }
  async fetch(op, ops = {}) {
    let path = endpoints_default.nodes.main;
    if (typeof op === "number") {
      if (!ops.force && this.cache.has(op))
        return this.cache.get(op);
      path = endpoints_default.nodes.get(op);
    } else {
      if (op)
        ops = op;
    }
    const data = await this.client.requests.get(path, ops, null, this);
    return this._patch(data);
  }
  fetchAll(options) {
    return this.getFetchAll(options);
  }
  async fetchDeployable(options) {
    const data = await this.client.requests.get(
      endpoints_default.nodes.deploy,
      void 0,
      options
    );
    return this._patch(data);
  }
  async query(entity, options) {
    if (!options.sort && !options.filter)
      throw new ValidationError("Sort or filter is required.");
    if (options.filter === "daemonTokenId")
      options.filter = "daemon_token_id";
    const payload = {};
    if (options.filter)
      payload.filter = [options.filter, entity];
    if (options.sort)
      payload.sort = options.sort;
    const data = await this.client.requests.get(
      endpoints_default.nodes.main,
      payload,
      null,
      this
    );
    return this._patch(data);
  }
  async getConfig(id) {
    const data = await this.client.requests.get(endpoints_default.nodes.config(id));
    return caseConv_default.toCamelCase(data);
  }
  async create(options) {
    const payload = caseConv_default.toSnakeCase(options);
    const data = await this.client.requests.post(
      endpoints_default.nodes.main,
      payload
    );
    return this._patch(data);
  }
  async update(id, options) {
    if (!Object.keys(options).length)
      throw new ValidationError("Too few options to update the node.");
    const _node = await this.fetch(id);
    options = Object.assign(options, _node);
    const payload = caseConv_default.toSnakeCase(options);
    const data = await this.client.requests.patch(
      endpoints_default.nodes.get(id),
      payload
    );
    return this._patch(data);
  }
  async delete(id) {
    await this.client.requests.delete(endpoints_default.nodes.get(id));
    this.cache.delete(id);
  }
};
__name(NodeManager, "NodeManager");

// src/http/RequestManager.ts
import axios from "axios";
import { EventEmitter } from "events";

// src/util/query.ts
var buildQuery = /* @__PURE__ */ __name((args, allowed) => {
  const parsed = [];
  if (args.page)
    parsed.push(`page=${args.page}`);
  if (args.perPage && args.perPage > 0) {
    if (args.perPage > 100)
      args.perPage = 100;
    parsed.push(`per_page=${args.perPage}`);
  }
  if (args.filter) {
    if (!allowed.filters?.includes(args.filter[0]))
      throw new ValidationError(
        `Invalid filter argument '${args.filter[0]}'.`
      );
    parsed.push(`filter[${args.filter[0]}]=${args.filter[1]}`);
  }
  if (args.include) {
    for (const arg of args.include) {
      if (!allowed.includes.includes(arg))
        throw new ValidationError(`Invalid include argument '${arg}'.`);
    }
    if (args.include?.length)
      parsed.push(`include=${args.include}`);
  }
  if (args.sort) {
    if (!allowed.sorts.includes(args.sort))
      throw new ValidationError(`Invalid sort argument '${args.sort}'.`);
    parsed.push(`sort=${args.sort}`);
  }
  if (!parsed.length)
    return "";
  return "?" + parsed.join("&");
}, "buildQuery");

// src/http/RequestManager.ts
var RequestManager = class extends EventEmitter {
  constructor(_type, _domain, _auth) {
    super();
    this._type = _type;
    this._domain = _domain;
    this._auth = _auth;
    this.instance = axios.create({
      baseURL: `${this._domain}/api/${this._type.toLowerCase()}`
    });
    this._ping = -1;
    this._start = 0;
  }
  emit(event, ...args) {
    return super.emit(event, ...args);
  }
  on(event, listener) {
    super.on(event, listener);
    return this;
  }
  once(event, listener) {
    super.once(event, listener);
    return this;
  }
  off(event, listener) {
    super.off(event, listener);
    return this;
  }
  getHeaders() {
    return {
      "User-Agent": `PteroJS ${this._type} v${version}`,
      "Content-Type": "application/json",
      Accept: "application/json, text/plain",
      Authorization: `Bearer ${this._auth}`
    };
  }
  debug(...data) {
    data.map((d) => `[HTTP] ${d}`).forEach((d) => super.emit("debug", d));
  }
  async _make(method, path, body) {
    const headers = this.getHeaders();
    if (body !== null && body !== void 0) {
      if (typeof body === "string") {
        headers["Content-Type"] = "text/plain";
      } else {
        body = JSON.stringify(body);
      }
      super.emit("preRequest", body);
    }
    this.debug(
      `requesting: ${method} ${path}`,
      `payload: ${body ? headers["Content-Type"] : "none"}`
    );
    this._start = Date.now();
    return await this.instance.request({
      method,
      url: path,
      headers,
      data: body
    }).then((r) => this.handleResponse(r)).catch((e) => this.handleError(e));
  }
  async raw(method, url, body) {
    const headers = this.getHeaders();
    if (body !== null && body !== void 0) {
      if (typeof body === "string") {
        headers["Content-Type"] = "text/plain";
      } else {
        body = JSON.stringify(body);
      }
      super.emit("preRequest", body);
    }
    this.debug(
      `requesting: ${method} ${url}`,
      `payload: ${body ? headers["Content-Type"] : "none"}`
    );
    this._start = Date.now();
    return await axios.request({
      url,
      method,
      headers,
      data: body
    }).then((r) => this.handleResponse(r)).catch((e) => this.handleError(e));
  }
  handleResponse(res) {
    this._ping = Date.now() - this._start;
    this.debug(
      `received status: ${res.status} (${this._ping}ms)`,
      `body: ${res.data ? res.headers["content-type"] : "none"}`
    );
    if ([202, 204].includes(res.status))
      return;
    super.emit("postRequest", res.data);
    if (res.data.object && res.data.object === "null_resource")
      throw new RequestError("Request returned a null resource object");
    return res.data;
  }
  handleError(err) {
    this._ping = Date.now() - this._start;
    this.debug(
      `received error: ${err.name} (${this._ping}ms)`,
      `message: ${err.message}`
    );
    if (err.response === void 0)
      throw new RequestError(
        `An unknown request error occurred: ${err.message}`
      );
    if (err.response.status >= 500)
      throw new RequestError(
        `Received an unexpected response from the API (code ${err.response.status})`
      );
    throw new PteroAPIError(err.response.data);
  }
  get(path, params, body, cls) {
    const query = params && cls ? buildQuery(params, cls.getQueryOptions()) : "";
    return this._make("GET", path + query, body);
  }
  post(path, body) {
    return this._make("POST", path, body);
  }
  patch(path, body) {
    return this._make("PATCH", path, body);
  }
  put(path, body) {
    return this._make("PUT", path, body);
  }
  delete(path, body) {
    return this._make("DELETE", path, body);
  }
};
__name(RequestManager, "RequestManager");

// src/structures/Permissions.ts
var Flags = /* @__PURE__ */ ((Flags2) => {
  Flags2["WEBSOCKET_CONNECT"] = "websocket.connect";
  Flags2["CONTROL_CONSOLE"] = "control.console";
  Flags2["CONTROL_START"] = "control.start";
  Flags2["CONTROL_STOP"] = "control.stop";
  Flags2["CONTROL_RESTART"] = "control.restart";
  Flags2["USER_CREATE"] = "user.create";
  Flags2["USER_READ"] = "user.read";
  Flags2["USER_UPDATE"] = "user.update";
  Flags2["USER_DELETE"] = "user.delete";
  Flags2["FILE_CREATE"] = "file.create";
  Flags2["FILE_READ"] = "file.read";
  Flags2["FILE_READ_CONTENT"] = "file.read-content";
  Flags2["FILE_UPDATE"] = "file.update";
  Flags2["FILE_DELETE"] = "file.delete";
  Flags2["FILE_ARCHIVE"] = "file.archive";
  Flags2["FILE_SFTP"] = "file.sftp";
  Flags2["BACKUP_CREATE"] = "backup.create";
  Flags2["BACKUP_READ"] = "backup.read";
  Flags2["BACKUP_UPDATE"] = "backup.update";
  Flags2["BACKUP_DELETE"] = "backup.delete";
  Flags2["ALLOCATION_READ"] = "allocation.read";
  Flags2["ALLOCATION_CREATE"] = "allocation.create";
  Flags2["ALLOCATION_UPDATE"] = "allocation.update";
  Flags2["ALLOCATION_DELETE"] = "allocation.delete";
  Flags2["STARTUP_READ"] = "startup.read";
  Flags2["STARTUP_UPDATE"] = "startup.update";
  Flags2["DATABASE_CREATE"] = "database.create";
  Flags2["DATABASE_READ"] = "database.read";
  Flags2["DATABASE_UPDATE"] = "database.update";
  Flags2["DATABASE_DELETE"] = "database.delete";
  Flags2["DATABASE_VIEW_PASSWORD"] = "database.view_password";
  Flags2["SCHEDULE_CREATE"] = "schedule.create";
  Flags2["SCHEDULE_READ"] = "schedule.read";
  Flags2["SCHEDULE_UPDATE"] = "schedule.update";
  Flags2["SCHEDULE_DELETE"] = "schedule.delete";
  Flags2["SETTINGS_RENAME"] = "settings.rename";
  Flags2["SETTINGS_REINSTALL"] = "settings.reinstall";
  Flags2["ADMIN_WEBSOCKET_ERRORS"] = "admin.websocket.errors";
  Flags2["ADMIN_WEBSOCKET_INSTALL"] = "admin.websocket.install";
  Flags2["ADMIN_WEBSOCKET_TRANSFER"] = "admin.websocket.transfer";
  return Flags2;
})(Flags || {});
var Permissions = class {
  static get CONTROL() {
    return Object.freeze([
      "control.console" /* CONTROL_CONSOLE */,
      "control.start" /* CONTROL_START */,
      "control.stop" /* CONTROL_STOP */,
      "control.restart" /* CONTROL_RESTART */
    ]);
  }
  static get USERS() {
    return Object.freeze([
      "user.create" /* USER_CREATE */,
      "user.read" /* USER_READ */,
      "user.update" /* USER_UPDATE */,
      "user.delete" /* USER_DELETE */
    ]);
  }
  static get FILES() {
    return Object.freeze([
      "file.create" /* FILE_CREATE */,
      "file.read" /* FILE_READ */,
      "file.read-content" /* FILE_READ_CONTENT */,
      "file.update" /* FILE_UPDATE */,
      "file.delete" /* FILE_DELETE */,
      "file.archive" /* FILE_ARCHIVE */,
      "file.sftp" /* FILE_SFTP */
    ]);
  }
  static get BACKUPS() {
    return Object.freeze([
      "backup.create" /* BACKUP_CREATE */,
      "backup.read" /* BACKUP_READ */,
      "backup.update" /* BACKUP_UPDATE */,
      "backup.delete" /* BACKUP_DELETE */
    ]);
  }
  static get ALLOCATIONS() {
    return Object.freeze([
      "allocation.read" /* ALLOCATION_READ */,
      "allocation.create" /* ALLOCATION_CREATE */,
      "allocation.update" /* ALLOCATION_UPDATE */,
      "allocation.delete" /* ALLOCATION_DELETE */
    ]);
  }
  static get STARTUPS() {
    return Object.freeze(["startup.read" /* STARTUP_READ */, "startup.update" /* STARTUP_UPDATE */]);
  }
  static get DATABASES() {
    return Object.freeze([
      "database.create" /* DATABASE_CREATE */,
      "database.read" /* DATABASE_READ */,
      "database.update" /* DATABASE_UPDATE */,
      "database.delete" /* DATABASE_DELETE */,
      "database.view_password" /* DATABASE_VIEW_PASSWORD */
    ]);
  }
  static get SCHEDULES() {
    return Object.freeze([
      "schedule.create" /* SCHEDULE_CREATE */,
      "schedule.read" /* SCHEDULE_READ */,
      "schedule.update" /* SCHEDULE_UPDATE */,
      "schedule.delete" /* SCHEDULE_DELETE */
    ]);
  }
  static get SETTINGS() {
    return Object.freeze(["settings.rename" /* SETTINGS_RENAME */, "settings.reinstall" /* SETTINGS_REINSTALL */]);
  }
  static get ADMIN() {
    return Object.freeze([
      "admin.websocket.errors" /* ADMIN_WEBSOCKET_ERRORS */,
      "admin.websocket.install" /* ADMIN_WEBSOCKET_INSTALL */,
      "admin.websocket.transfer" /* ADMIN_WEBSOCKET_TRANSFER */
    ]);
  }
  constructor(...perms) {
    this.value = Permissions.resolve(...perms);
  }
  static resolve(...perms) {
    const res = [];
    const values = Object.values(Flags);
    if (perms.some((p) => p === "*"))
      return values;
    for (const p of perms) {
      if (p in Flags || values.includes(p)) {
        res.push(p);
      } else {
        throw new Error(`unknown permission '${p}'`);
      }
    }
    return res;
  }
  hasAny(...perms) {
    const res = Permissions.resolve(...perms);
    return res.some((p) => this.value.includes(p));
  }
  hasAll(...perms) {
    const res = Permissions.resolve(...perms);
    return res.every((p) => this.value.includes(p));
  }
  isAdmin() {
    return this.value.some(
      (p) => [
        "admin.websocket.errors" /* ADMIN_WEBSOCKET_ERRORS */,
        "admin.websocket.install" /* ADMIN_WEBSOCKET_INSTALL */,
        "admin.websocket.transfer" /* ADMIN_WEBSOCKET_TRANSFER */
      ].includes(p)
    );
  }
  add(...perms) {
    this.value = this.value.concat(Permissions.resolve(...perms));
    return this;
  }
  remove(...perms) {
    const res = Permissions.resolve(...perms);
    this.value = this.value.filter((p) => !res.includes(p));
    return this;
  }
  serialize() {
    const res = {};
    for (let [k, v] of Object.entries(Flags))
      res[k] = this.value.includes(v);
    return res;
  }
};
__name(Permissions, "Permissions");

// src/client/endpoints.ts
var endpoints_default2 = {
  account: {
    main: "/account",
    tfa: "/account/two-factor",
    email: "/account/email",
    password: "/account/password",
    apikeys: {
      main: "/account/api-keys",
      get: (k) => `/account/api-keys/${k}`
    },
    activity: "/account/activity",
    sshkeys: {
      main: "/account/ssh-keys",
      remove: "/account/ssh-keys/remove"
    }
  },
  servers: {
    main: "",
    get: (s) => `/servers/${s}`,
    databases: {
      main: (s) => `/servers/${s}/databases`,
      get: (s, id) => `/servers/${s}/databases/${id}`,
      rotate: (s, id) => `/servers/${s}/databases/${id}/rotate-password`
    },
    files: {
      main: (s) => `/servers/${s}/files/list`,
      contents: (s, f) => `/servers/${s}/files/contents?file=${f}`,
      download: (s, f) => `/servers/${s}/files/download?file=${f}`,
      rename: (s) => `/servers/${s}/files/rename`,
      copy: (s) => `/servers/${s}/files/copy`,
      write: (s, f) => `/servers/${s}/files/write?file=${f}`,
      compress: (s) => `/servers/${s}/files/compress`,
      decompress: (s) => `/servers/${s}/files/decompress`,
      delete: (s) => `/servers/${s}/files/delete`,
      create: (s) => `/servers/${s}/files/create-folder`,
      upload: (s) => `/servers/${s}/files/upload`,
      chmod: (s) => `/servers/${s}/files/chmod`
    },
    schedules: {
      main: (s) => `/servers/${s}/schedules`,
      get: (s, id) => `/servers/${s}/schedules/${id}`,
      exec: (s, id) => `/servers/${s}/schedules/${id}/execute`,
      tasks: {
        main: (s, id) => `/servers/${s}/schedules/${id}/tasks`,
        get: (s, id, t) => `/servers/${s}/schedules/${id}/tasks/${t}`
      }
    },
    network: {
      main: (s) => `/servers/${s}/network/allocations`,
      get: (s, id) => `/servers/${s}/network/allocations/${id}`,
      primary: (s, id) => `/servers/${s}/network/allocations/${id}/primary`
    },
    users: {
      main: (s) => `/servers/${s}/users`,
      get: (s, id) => `/servers/${s}/users/${id}`
    },
    backups: {
      main: (s) => `/servers/${s}/backups`,
      get: (s, id) => `/servers/${s}/backups/${id}`,
      lock: (s, id) => `/servers/${s}/backups/${id}/lock`,
      download: (s, id) => `/servers/${s}/backups/${id}/download`,
      restore: (s, id) => `/servers/${s}/backups/${id}/restore`
    },
    startup: {
      get: (s) => `/servers/${s}/startup`,
      var: (s) => `/servers/${s}/startup/variable`
    },
    settings: {
      image: (s) => `/servers/${s}/settings/docker-image`,
      rename: (s) => `/servers/${s}/settings/rename`,
      reinstall: (s) => `/servers/${s}/settings/reinstall`
    },
    ws: (s) => `/servers/${s}/websocket`,
    resources: (s) => `/servers/${s}/resources`,
    command: (s) => `/servers/${s}/command`,
    power: (s) => `/servers/${s}/power`
  },
  permissions: "/permissions"
};

// src/structures/User.ts
var BaseUser = class {
  constructor(client, data) {
    this.client = client;
    this.id = data.id;
    this._patch(data);
  }
  _patch(data) {
    if ("username" in data)
      this.username = data.username;
    if ("email" in data)
      this.email = data.email;
    if ("first_name" in data)
      this.firstname = data.first_name;
    if ("last_name" in data)
      this.lastname = data.last_name;
    if ("language" in data)
      this.language = data.language;
  }
  toJSON() {
    return caseConv_default.toSnakeCase(this, {
      ignore: ["client"],
      map: { firstname: "first_name", lastname: "last_name" }
    });
  }
  toString() {
    return this.firstname + " " + this.lastname;
  }
};
__name(BaseUser, "BaseUser");
var User = class extends BaseUser {
  constructor(client, data) {
    super(client, data);
    this.client = client;
    this.createdAt = new Date(data.created_at);
    this.createdTimestamp = this.createdAt.getTime();
    if ("relationships" in data) {
      this.servers = "servers" in data.relationships ? this.client.servers.resolve(data) : void 0;
    }
  }
  _patch(data) {
    super._patch(data);
    this.externalId = data.external_id || void 0;
    this.updatedAt = data.updated_at ? new Date(data.updated_at) : void 0;
    this.updatedTimestamp = this.updatedAt?.getTime() || void 0;
    if ("root_admin" in data)
      this.isAdmin = data.root_admin;
    if ("2fa" in data)
      this.twoFactor = data["2fa"];
  }
  get adminURL() {
    return `${this.client.domain}/admin/users/view/${this.id}`;
  }
};
__name(User, "User");
var SubUser = class {
  constructor(client, serverId, data) {
    this.client = client;
    this.uuid = data.uuid;
    this.serverId = serverId;
    this.createdAt = new Date(data.created_at);
    this.createdTimestamp = this.createdAt.getTime();
    this._patch(data);
  }
  _patch(data) {
    if ("username" in data)
      this.username = data.username;
    if ("email" in data)
      this.email = data.email;
    if ("image" in data)
      this.image = data.image;
    if ("2fa_enabled" in data)
      this.enabled = data["2fa_enabled"];
    if ("permissions" in data)
      this.permissions = new Permissions(...data.permissions ?? []);
  }
  get panelURL() {
    return `${this.client.domain}/server/${this.serverId}/users`;
  }
  async setPermissions(...permissions) {
    const perms = Permissions.resolve(...permissions);
    if (!perms.length)
      throw new ValidationError(
        "No permissions specified for the subuser."
      );
    const data = await this.client.requests.post(
      endpoints_default2.servers.users.get(this.serverId, this.uuid),
      { permissions: perms }
    );
    this._patch(data);
    return this;
  }
};
__name(SubUser, "SubUser");
var Account = class extends BaseUser {
  constructor(client) {
    super(client, {});
    this.client = client;
    this.isAdmin = false;
    this.tokens = [];
    this.apikeys = [];
  }
  get panelURL() {
    return `${this.client.domain}/account`;
  }
  async fetch() {
    const data = await this.client.requests.get(endpoints_default2.account.main);
    super._patch(data.attributes);
    this.id = data.attributes.id;
    this.isAdmin = data.attributes.admin;
    return this;
  }
  async updateEmail(email, password) {
    if (this.email === email)
      return Promise.resolve(this);
    await this.client.requests.put(endpoints_default2.account.email, {
      email,
      password
    });
    this.email = email;
    return this;
  }
  async updatePassword(oldPass, newPass) {
    if (oldPass === newPass)
      return Promise.resolve(this);
    await this.client.requests.put(endpoints_default2.account.password, {
      current_password: oldPass,
      password: newPass,
      password_confirmation: newPass
    });
    return this;
  }
  async get2FACode() {
    const data = await this.client.requests.get(endpoints_default2.account.tfa);
    return data.data.image_url_data;
  }
  async enable2FA(code) {
    const data = await this.client.requests.post(endpoints_default2.account.tfa, {
      code
    });
    this.tokens.push(...data.attributes.tokens);
    return this.tokens;
  }
  async disable2FA(password) {
    await this.client.requests.delete(endpoints_default2.account.tfa, { password });
    this.tokens = [];
  }
  async fetchKeys() {
    const data = await this.client.requests.get(
      endpoints_default2.account.apikeys.main
    );
    this.apikeys = data.data.map((o) => {
      let k = caseConv_default.toCamelCase(o.attributes);
      k.createdAt = new Date(k.createdAt);
      k.lastUsedAt &&= new Date(k.lastUsedAt);
      return k;
    });
    return this.apikeys;
  }
  async createKey(description, allowedIps = []) {
    const data = await this.client.requests.post(
      endpoints_default2.account.apikeys.main,
      { description, allowed_ips: allowedIps }
    );
    const key = caseConv_default.toCamelCase(data.attributes);
    key.createdAt = new Date(key.createdAt);
    key.lastUsedAt &&= new Date(key.lastUsedAt);
    key.token = data.meta.secret_token;
    this.apikeys.push(key);
    return key;
  }
  async deleteKey(id) {
    await this.client.requests.delete(endpoints_default2.account.apikeys.get(id));
    this.apikeys = this.apikeys.filter((k) => k.identifier !== id);
  }
  async fetchActivities() {
    const data = await this.client.requests.get(endpoints_default2.account.activity);
    const act = data.data.map((o) => {
      const a = caseConv_default.toCamelCase(o.attributes);
      a.timestamp = new Date(a.timestamp);
      return a;
    });
    return act;
  }
  async fetchSSHKeys() {
    const data = await this.client.requests.get(
      endpoints_default2.account.sshkeys.main
    );
    const keys = data.data.map((o) => {
      const k = caseConv_default.toCamelCase(o.attributes);
      k.createdAt = new Date(k.createdAt);
      return k;
    });
    return keys;
  }
  async createSSHKey(name, publicKey) {
    const data = await this.client.requests.post(
      endpoints_default2.account.sshkeys.main,
      { name, public_key: publicKey }
    );
    const key = caseConv_default.toCamelCase(data.attributes);
    key.createdAt = new Date(key.createdAt);
    return key;
  }
  async removeSSHKey(fingerprint) {
    await this.client.requests.post(endpoints_default2.account.sshkeys.remove, {
      fingerprint
    });
  }
};
__name(Account, "Account");

// src/application/UserManager.ts
var UserManager = class extends BaseManager {
  constructor(client) {
    super();
    this.client = client;
    this.cache = new Dict();
  }
  get FILTERS() {
    return Object.freeze(["email", "uuid", "username", "external_id"]);
  }
  get INCLUDES() {
    return Object.freeze(["servers"]);
  }
  get SORTS() {
    return Object.freeze(["id", "-id", "uuid", "-uuid"]);
  }
  _patch(data) {
    if (data?.meta?.pagination) {
      this.meta = caseConv_default.toCamelCase(data.meta.pagination, {
        ignore: ["current_page"]
      });
      this.meta.current = data.meta.pagination.current_page;
    }
    if (data?.data) {
      const res = new Dict();
      for (const o of data.data) {
        const s = new User(this.client, o.attributes);
        res.set(s.id, s);
      }
      if (this.client.options.servers.cache)
        this.cache = this.cache.join(res);
      return res;
    }
    const u = new User(this.client, data.attributes);
    if (this.client.options.servers.cache)
      this.cache.set(u.id, u);
    return u;
  }
  resolve(obj) {
    if (obj instanceof User)
      return obj;
    if (typeof obj === "number")
      return this.cache.get(obj);
    if (typeof obj === "string")
      return this.cache.find(
        (s) => s.username === obj || s.firstname === obj || s.lastname === obj
      );
    if (obj.relationships?.user)
      return this._patch(obj.relationships.user);
    return void 0;
  }
  adminURLFor(id) {
    return `${this.client.domain}/admin/users/view/${id}`;
  }
  async fetch(op, ops = {}) {
    let path;
    switch (typeof op) {
      case "number": {
        if (!ops.force && this.cache.has(op))
          return this.cache.get(op);
        path = endpoints_default.users.get(op);
        break;
      }
      case "string": {
        if (!ops.force) {
          const u = this.cache.find((u2) => u2.externalId === op);
          if (u)
            return u;
        }
        path = endpoints_default.users.ext(op);
        break;
      }
      case "undefined":
      case "object": {
        path = endpoints_default.users.main;
        if (op)
          ops = op;
        break;
      }
      default:
        throw new ValidationError(
          `expected user id, external id or fetch options; got ${typeof op}`
        );
    }
    const data = await this.client.requests.get(path, ops, null, this);
    return this._patch(data);
  }
  fetchExternal(id, options) {
    return this.fetch(id, options);
  }
  fetchAll(options) {
    return this.getFetchAll(options);
  }
  async query(entity, options) {
    if (!options.sort && !options.filter)
      throw new ValidationError("Sort or filter is required.");
    if (options.filter === "externalId")
      options.filter = "external_id";
    const payload = {};
    if (options.filter)
      payload.filter = [options.filter, entity];
    if (options.sort)
      payload.sort = options.sort;
    const data = await this.client.requests.get(
      endpoints_default.users.main,
      payload,
      null,
      this
    );
    return this._patch(data);
  }
  async create(options) {
    const payload = caseConv_default.toSnakeCase(options, {
      map: {
        firstname: "first_name",
        lastname: "last_name",
        isAdmin: "root_admin"
      }
    });
    const data = await this.client.requests.post(
      endpoints_default.users.main,
      payload
    );
    return this._patch(data);
  }
  async update(id, options) {
    if (!Object.keys(options).length)
      throw new ValidationError("Too few options to update user.");
    const user = await this.fetch(id);
    options.username ||= user.username;
    options.firstname ||= user.firstname;
    options.lastname ||= user.lastname;
    options.email ||= user.email;
    options.isAdmin ??= user.isAdmin;
    if (!("externalId" in options))
      options.externalId = user.externalId;
    const payload = caseConv_default.toSnakeCase(options, {
      map: {
        firstname: "first_name",
        lastname: "last_name",
        isAdmin: "root_admin"
      }
    });
    const data = await this.client.requests.patch(
      endpoints_default.users.get(id),
      payload
    );
    return this._patch(data);
  }
  async delete(id) {
    await this.client.requests.delete(endpoints_default.users.get(id));
    this.cache.delete(id);
  }
};
__name(UserManager, "UserManager");

// src/util/config.ts
import { join } from "path";
var DEFAULT = {
  APPLICATION: {
    users: {
      fetch: false,
      cache: true,
      max: -1
    },
    nodes: {
      fetch: false,
      cache: true,
      max: -1
    },
    nests: {
      fetch: false,
      cache: true,
      max: -1
    },
    servers: {
      fetch: false,
      cache: true,
      max: -1
    },
    locations: {
      fetch: false,
      cache: true,
      max: -1
    }
  },
  CLIENT: {
    ws: false,
    fetchClient: true,
    servers: {
      fetch: false,
      cache: true,
      max: -1
    },
    subUsers: {
      fetch: false,
      cache: true,
      max: -1
    },
    disableEvents: []
  }
};
function parseAs(from, to) {
  const res = {};
  for (const [k, v] of Object.entries(to))
    res[k] = k in from ? from[k] : v;
  for (const [k, v] of Object.entries(res))
    if (v.max === -1)
      res[k].max = Infinity;
  return res;
}
__name(parseAs, "parseAs");
function appConfig(options) {
  if (options !== void 0 && typeof options === "object" && Object.keys(options).length)
    return parseAs(options, DEFAULT.APPLICATION);
  try {
    options = __require(join(process.cwd(), "pterojs.json"));
    return parseAs(options.application ?? {}, DEFAULT.APPLICATION);
  } catch {
    return DEFAULT.APPLICATION;
  }
}
__name(appConfig, "appConfig");
function clientConfig(options) {
  if (options !== void 0 && typeof options === "object" && Object.keys(options).length)
    return parseAs(options, DEFAULT.CLIENT);
  try {
    options = __require(join(process.cwd(), "pterojs.json"));
    return parseAs(options.client ?? {}, DEFAULT.CLIENT);
  } catch {
    return DEFAULT.CLIENT;
  }
}
__name(clientConfig, "clientConfig");
var config_default = {
  DEFAULT,
  parseAs,
  appConfig,
  clientConfig
};

// src/application/index.ts
var PteroApp = class {
  constructor(domain, auth, options = {}) {
    if (!/https?\:\/\/(?:localhost\:\d{4}|[\w\.\-]{3,256})/gi.test(domain))
      throw new ValidationError(
        "Domain URL must start with 'http://' or 'https://' and must be bound to a port if using localhost."
      );
    if (domain.endsWith("/"))
      domain = domain.slice(0, -1);
    this.domain = domain;
    this.auth = auth;
    this.options = config_default.appConfig({ application: options });
    this.allocations = new NodeAllocationManager(this);
    this.locations = new NodeLocationManager(this);
    this.nests = new NestManager(this);
    this.nodes = new NodeManager(this);
    this.servers = new ApplicationServerManager(this);
    this.users = new UserManager(this);
    this.requests = new RequestManager("Application", domain, auth);
  }
  get ping() {
    return this.requests._ping;
  }
};
__name(PteroApp, "PteroApp");

// src/client/BackupManager.ts
import { existsSync, writeFileSync } from "fs";
var BackupManager = class extends BaseManager {
  constructor(client, serverId) {
    super();
    this.client = client;
    this.cache = new Dict();
    this.serverId = serverId;
  }
  get FILTERS() {
    return Object.freeze([]);
  }
  get INCLUDES() {
    return Object.freeze([]);
  }
  get SORTS() {
    return Object.freeze([]);
  }
  _patch(data) {
    if (data.data) {
      const res = new Dict();
      for (let o of data.data) {
        const b2 = caseConv_default.toCamelCase(o.attributes, {
          map: {
            is_successful: "successful",
            is_locked: "locked"
          }
        });
        b2.createdAt = new Date(b2.createdAt);
        b2.completedAt &&= new Date(b2.completedAt);
        res.set(b2.uuid, b2);
      }
      this.cache.update(res);
      return res;
    }
    const b = caseConv_default.toCamelCase(data.attributes, {
      map: {
        is_successful: "successful",
        is_locked: "locked"
      }
    });
    b.createdAt = new Date(b.createdAt);
    b.completedAt &&= new Date(b.completedAt);
    this.cache.set(b.uuid, b);
    return b;
  }
  async fetch(op, ops = {}) {
    let path = endpoints_default2.servers.backups.main(this.serverId);
    if (typeof op === "string") {
      if (!ops.force && this.cache.has(op))
        return this.cache.get(op);
      path = endpoints_default2.servers.backups.get(this.serverId, op);
    } else {
      if (op)
        ops = op;
    }
    const data = await this.client.requests.get(path, ops, null, this);
    return this._patch(data);
  }
  async create(options = {}) {
    const data = await this.client.requests.post(
      endpoints_default2.servers.backups.main(this.serverId),
      options
    );
    return this._patch(data);
  }
  async toggleLock(id) {
    const data = await this.client.requests.post(
      endpoints_default2.servers.backups.lock(this.serverId, id)
    );
    return this._patch(data);
  }
  async getDownloadURL(id) {
    const data = await this.client.requests.get(
      endpoints_default2.servers.backups.download(this.serverId, id)
    );
    return data.attributes.url;
  }
  async download(id, dest) {
    if (existsSync(dest))
      throw new ValidationError(
        "A file or directory exists at this path."
      );
    const url = await this.getDownloadURL(id);
    const data = await this.client.requests.raw("GET", url);
    writeFileSync(dest, data.toString(), { encoding: "utf-8" });
  }
  async restore(id) {
    await this.client.requests.post(
      endpoints_default2.servers.backups.restore(this.serverId, id)
    );
  }
  async delete(id) {
    await this.client.requests.delete(
      endpoints_default2.servers.backups.get(this.serverId, id)
    );
    this.cache.delete(id);
  }
};
__name(BackupManager, "BackupManager");

// src/client/ClientDatabaseManager.ts
var ClientDatabaseManager = class extends BaseManager {
  constructor(client, serverId) {
    super();
    this.client = client;
    this.cache = new Dict();
    this.serverId = serverId;
  }
  get FILTERS() {
    return Object.freeze([]);
  }
  get INCLUDES() {
    return Object.freeze(["password"]);
  }
  get SORTS() {
    return Object.freeze([]);
  }
  _patch(data) {
    if (data.data) {
      const res = new Dict();
      for (let o of data.data) {
        const d2 = caseConv_default.toCamelCase(o.attributes);
        res.set(d2.id, d2);
      }
      this.cache.update(res);
      return res;
    }
    const d = caseConv_default.toCamelCase(data.attributes);
    this.cache.set(d.id, d);
    return d;
  }
  async fetch(options = {}) {
    const data = await this.client.requests.get(
      endpoints_default2.servers.databases.main(this.serverId),
      options,
      null,
      this
    );
    return this._patch(data);
  }
  async create(database, remote) {
    const data = await this.client.requests.post(
      endpoints_default2.servers.databases.main(this.serverId),
      { database, remote }
    );
    return this._patch(data);
  }
  async rotate(id) {
    const data = await this.client.requests.post(
      endpoints_default2.servers.databases.rotate(this.serverId, id)
    );
    return this._patch(data);
  }
  async delete(id) {
    await this.client.requests.delete(
      endpoints_default2.servers.databases.get(this.serverId, id)
    );
    this.cache.delete(id);
  }
};
__name(ClientDatabaseManager, "ClientDatabaseManager");

// src/client/FileManager.ts
import { existsSync as existsSync2, writeFileSync as writeFileSync2 } from "fs";
var FileManager = class {
  constructor(client, serverId) {
    this.client = client;
    this.cache = new Dict();
    this.serverId = serverId;
  }
  _patch(dir, data) {
    const res = new Dict();
    for (let o of data.data) {
      let f = caseConv_default.toCamelCase(o.attributes);
      f.modeBits = BigInt(f.modeBits);
      f.createdAt = new Date(f.createdAt);
      f.modifiedAt &&= new Date(f.modifiedAt);
      res.set(f.name, f);
    }
    const hold = this.cache.get(dir) || new Dict();
    this.cache.set(dir, hold.join(res));
    return res;
  }
  clean(path) {
    if (path.startsWith("."))
      path = path.slice(1);
    return encodeURIComponent(path);
  }
  async fetch(dir = "/") {
    const data = await this.client.requests.get(
      endpoints_default2.servers.files.main(this.serverId) + `?directory=${this.clean(dir)}`
    );
    return this._patch(dir, data);
  }
  async getContents(path) {
    const data = await this.client.requests.get(
      endpoints_default2.servers.files.contents(this.serverId, this.clean(path))
    );
    return data.toString();
  }
  async getDownloadURL(path) {
    const data = await this.client.requests.get(
      endpoints_default2.servers.files.download(this.serverId, this.clean(path))
    );
    return data.attributes.url;
  }
  async download(path, dest) {
    if (existsSync2(dest))
      throw new ValidationError(
        "A file or directory exists at this path."
      );
    const url = await this.getDownloadURL(path);
    const data = await this.client.requests.raw("GET", url);
    writeFileSync2(dest, data.toString(), { encoding: "utf-8" });
  }
  async getUploadURL(dir = "/") {
    const data = await this.client.requests.get(
      endpoints_default2.servers.files.upload(this.serverId) + `?directory=${this.clean(dir)}`
    );
    return data.attributes.url;
  }
  async upload(dir, file) {
  }
  async write(path, content) {
    await this.client.requests.post(
      endpoints_default2.servers.files.write(this.serverId, this.clean(path)),
      content
    );
  }
  async createFolder(path, name) {
    await this.client.requests.post(
      endpoints_default2.servers.files.create(this.serverId),
      { root: path, name }
    );
  }
  async rename(path, files) {
    await this.client.requests.put(
      endpoints_default2.servers.files.rename(this.serverId),
      { root: path, files }
    );
  }
  async chmod(dir, files) {
    files = files.map((f) => {
      if (f.file.startsWith("."))
        f.file = f.file.slice(1);
      return f;
    });
    await this.client.requests.post(
      endpoints_default2.servers.files.chmod(this.serverId),
      { root: dir, files }
    );
  }
  async copy(path) {
    await this.client.requests.post(
      endpoints_default2.servers.files.copy(this.serverId),
      { location: path }
    );
  }
  async compress(dir, files) {
    files = files.map((f2) => f2.startsWith(".") ? f2.slice(1) : f2);
    const data = await this.client.requests.post(
      endpoints_default2.servers.files.compress(this.serverId),
      { root: dir, files }
    );
    let f = caseConv_default.toCamelCase(data.attributes);
    f.modeBits = BigInt(f.modeBits);
    f.createdAt = new Date(f.createdAt);
    f.modifiedAt &&= new Date(f.modifiedAt);
    return f;
  }
  async decompress(dir, file) {
    await this.client.requests.post(
      endpoints_default2.servers.files.decompress(this.serverId),
      { root: dir, file }
    );
  }
  async delete(dir, files) {
    files = files.map((f) => f.startsWith(".") ? f.slice(1) : f);
    await this.client.requests.post(
      endpoints_default2.servers.files.delete(this.serverId),
      { root: dir, files }
    );
  }
};
__name(FileManager, "FileManager");

// src/client/NetworkManager.ts
var NetworkManager = class {
  constructor(client, serverId) {
    this.client = client;
    this.cache = new Dict();
    this.serverId = serverId;
  }
  _patch(data) {
    if (data.data) {
      const res = new Dict();
      for (let o of data.data) {
        const a2 = caseConv_default.toCamelCase(o.attributes);
        a2.notes ||= null;
        res.set(a2.id, a2);
      }
      this.cache.update(res);
      return res;
    }
    const a = caseConv_default.toCamelCase(data);
    a.notes ||= null;
    this.cache.set(a.id, a);
    return a;
  }
  async fetch() {
    const data = await this.client.requests.get(
      endpoints_default2.servers.network.main(this.serverId)
    );
    return this._patch(data);
  }
  async setNote(id, notes) {
    const data = await this.client.requests.post(
      endpoints_default2.servers.network.get(this.serverId, id),
      { notes }
    );
    return this._patch(data);
  }
  async setPrimary(id) {
    const data = await this.client.requests.post(
      endpoints_default2.servers.network.primary(this.serverId, id)
    );
    return this._patch(data);
  }
  async unassign(id) {
    await this.client.requests.delete(
      endpoints_default2.servers.network.get(this.serverId, id)
    );
  }
};
__name(NetworkManager, "NetworkManager");

// src/client/SubUserManager.ts
var SubUserManager = class {
  constructor(client, serverId) {
    this.client = client;
    this.serverId = serverId;
    this.cache = new Dict();
  }
  _patch(data) {
    if (data?.data) {
      const res = new Dict();
      for (const o of data.data) {
        const s = new SubUser(this.client, this.serverId, o.attributes);
        res.set(s.uuid, s);
      }
      if (this.client.options.subUsers.cache)
        this.cache.update(res);
      return res;
    }
    const u = new SubUser(this.client, this.serverId, data.attributes);
    if (this.client.options.subUsers.cache)
      this.cache.set(u.uuid, u);
    return u;
  }
  resolve(obj) {
    if (obj instanceof SubUser)
      return obj;
    if (typeof obj === "number")
      return void 0;
    if (typeof obj === "string")
      return this.cache.get(obj);
    if (obj.relationships?.users)
      return this._patch(obj.relationships.users);
    return void 0;
  }
  get panelURL() {
    return `${this.client.domain}/server/${this.serverId}/users`;
  }
  async fetch(op, ops = {}) {
    let path = endpoints_default2.servers.users.main(this.serverId);
    if (typeof op === "string") {
      if (!ops.force && this.cache.has(op))
        return this.cache.get(op);
      path = endpoints_default2.servers.users.get(this.serverId, op);
    } else {
      if (op)
        ops = op;
    }
    const data = await this.client.requests.get(path, ops);
    return this._patch(data);
  }
  async add(email, permissions) {
    const perms = Permissions.resolve(...permissions);
    if (!perms.length)
      throw new ValidationError(
        "Need at least 1 permission for the subuser."
      );
    const data = await this.client.requests.post(
      endpoints_default2.servers.users.main(this.serverId),
      { email, permissions: perms }
    );
    return this._patch(data);
  }
  async setPermissions(id, permissions) {
    const perms = Permissions.resolve(...permissions);
    if (!perms.length)
      throw new ValidationError(
        "No permissions specified for the subuser."
      );
    const data = await this.client.requests.post(
      endpoints_default2.servers.users.get(this.serverId, id),
      { permissions: perms }
    );
    return this._patch(data);
  }
  async remove(id) {
    await this.client.requests.delete(
      endpoints_default2.servers.users.get(this.serverId, id)
    );
    this.cache.delete(id);
  }
};
__name(SubUserManager, "SubUserManager");

// src/structures/ClientServer.ts
var ClientServer = class {
  constructor(client, data) {
    this.client = client;
    this.uuid = data.uuid;
    this.identifier = data.identifier;
    this.backups = new BackupManager(client, data.identifier);
    this.databases = new ClientDatabaseManager(client, data.identifier);
    this.files = new FileManager(client, data.identifier);
    this.network = new NetworkManager(client, data.identifier);
    this.users = new SubUserManager(client, data.identifier);
    this._patch(data);
  }
  _patch(data) {
    if ("name" in data)
      this.name = data.name;
    if ("description" in data)
      this.description = data.description || void 0;
    if ("is_owner" in data)
      this.isOwner = data.is_owner;
    if ("node" in data)
      this.node = data.node;
    if ("sftp_details" in data)
      this.sftpDetails = data.sftp_details;
    if ("limits" in data)
      this.limits = caseConv_default.toCamelCase(data.limits);
    if ("feature_limits" in data)
      this.featureLimits = data.feature_limits;
    if ("egg_features" in data)
      this.eggFeatures = data.egg_features || void 0;
    if ("invocation" in data)
      this.invocation = data.invocation;
    if ("docker_image" in data)
      this.dockerImage = data.docker_image;
    if ("status" in data)
      this.status = data.status || void 0;
    if ("is_suspended" in data)
      this.suspended = data.is_suspended;
    if ("is_installing" in data)
      this.installing = data.is_installing;
    if ("is_transferring" in data)
      this.transferring = data.is_transferring;
  }
  get panelURL() {
    return `${this.client.domain}/server/${this.identifier}`;
  }
  async fetchResources() {
    return await this.client.servers.fetchResources(this.identifier);
  }
  async fetchStartup() {
    return await this.client.servers.fetchStartup(this.identifier);
  }
  async sendCommand(command) {
    await this.client.requests.post(
      endpoints_default2.servers.command(this.identifier),
      { command }
    );
  }
  async setPowerState(state) {
    await this.client.servers.setPowerState(this.identifier, state);
    this.status = state;
  }
  async setDockerImage(image) {
    await this.client.servers.setDockerImage(this.identifier, image);
    this.dockerImage = image;
  }
  async setVariable(key, value) {
    return await this.client.servers.setVariable(
      this.identifier,
      key,
      value
    );
  }
  async rename(name) {
    await this.client.servers.rename(this.identifier, name);
    this.name = name;
  }
  async reinstall() {
    await this.client.servers.reinstall(this.identifier);
    this.installing = true;
  }
  toJSON() {
    return caseConv_default.toSnakeCase(this, {
      ignore: ["client"],
      map: {
        suspended: "is_suspended",
        installing: "is_installing"
      }
    });
  }
  toString() {
    return this.name;
  }
};
__name(ClientServer, "ClientServer");

// src/client/ClientServerManager.ts
var ClientServerManager = class extends BaseManager {
  constructor(client) {
    super();
    this.client = client;
    this.cache = new Dict();
  }
  get FILTERS() {
    return Object.freeze([]);
  }
  get INCLUDES() {
    return Object.freeze(["egg", "subusers"]);
  }
  get SORTS() {
    return Object.freeze([]);
  }
  _patch(data) {
    if (data.meta)
      this.meta = caseConv_default.toCamelCase(data.meta);
    if (data?.data) {
      const res = new Dict();
      for (let o of data.data) {
        const s2 = new ClientServer(this.client, o.attributes);
        res.set(s2.identifier, s2);
      }
      if (this.client.options.servers.cache)
        this.cache.update(res);
      return res;
    }
    const s = new ClientServer(this.client, data.attributes);
    if (this.client.options.servers.cache)
      this.cache.set(s.identifier, s);
    return s;
  }
  panelURLFor(id) {
    return `${this.client.domain}/server/${id}`;
  }
  async fetch(op, ops = {}) {
    let path = endpoints_default2.servers.main;
    if (typeof op === "string") {
      if (!ops.force && this.cache.has(op))
        return this.cache.get(op);
      path = endpoints_default2.servers.get(op);
    } else {
      if (op)
        ops = op;
    }
    path += buildQuery(ops, this.getQueryOptions());
    if (ops.type)
      path += (path.includes("?") ? "&" : "?") + `type=${ops.type}`;
    const data = await this.client.requests.get(path);
    return this._patch(data);
  }
  async fetchResources(id) {
    const data = await this.client.requests.get(
      endpoints_default2.servers.resources(id)
    );
    return caseConv_default.toCamelCase(data.attributes);
  }
  async fetchStartup(id) {
    const data = await this.client.requests.get(
      endpoints_default2.servers.startup.get(id)
    );
    const parsed = caseConv_default.toCamelCase(data.meta);
    parsed.variables = data.data.map(
      (v) => caseConv_default.toCamelCase(v.attributes)
    );
    return parsed;
  }
  async sendCommand(id, command) {
    await this.client.requests.post(endpoints_default2.servers.command(id), {
      command
    });
  }
  async setPowerState(id, state) {
    if (!["start", "stop", "restart", "kill"].includes(state))
      throw new ValidationError(
        "Invalid power state, must be: start, stop, restart, or kill."
      );
    await this.client.requests.post(endpoints_default2.servers.power(id), {
      signal: state
    });
  }
  async setDockerImage(id, image) {
    await this.client.requests.put(endpoints_default2.servers.settings.image(id), {
      docker_image: image
    });
  }
  async setVariable(id, key, value) {
    if (typeof key !== "string")
      throw new ValidationError("variable key", "string", typeof key);
    if (typeof value !== "string")
      throw new ValidationError("variable value", "string", typeof value);
    const data = await this.client.requests.put(
      endpoints_default2.servers.startup.var(id),
      { key, value }
    );
    return caseConv_default.toCamelCase(data.attributes);
  }
  async rename(id, name) {
    await this.client.requests.post(endpoints_default2.servers.settings.rename(id), {
      name
    });
    if (this.cache.has(id)) {
      const s = this.cache.get(id);
      s.name = name;
      this.cache.set(id, s);
    }
  }
  async reinstall(id) {
    await this.client.requests.post(
      endpoints_default2.servers.settings.reinstall(id)
    );
  }
};
__name(ClientServerManager, "ClientServerManager");

// src/structures/Schedule.ts
var Schedule = class {
  constructor(client, serverId, data) {
    this.client = client;
    this.serverId = serverId;
    this.id = data.id;
    this.createdAt = new Date(data.created_at);
    this.tasks = new Dict();
    this._patch(data);
  }
  _patch(data) {
    if ("name" in data)
      this.name = data.name;
    if ("cron" in data)
      this.cron = caseConv_default.toCamelCase(data.cron);
    if ("is_active" in data)
      this.active = data.is_active;
    if ("is_processing" in data)
      this.processing = data.is_processing;
    if ("only_when_online" in data)
      this.onlyWhenOnline = data.only_when_online;
    if ("updated_at" in data)
      this.updatedAt = new Date(data.updated_at);
    if ("last_run_at" in data)
      this.lastRunAt = new Date(data.last_run_at);
    if ("next_run_at" in data)
      this.nextRunAt = new Date(data.next_run_at);
    if ("relationships" in data) {
      if ("tasks" in data.relationships)
        data.relationships.tasks.data.forEach(
          (t) => this._resolveTask(t)
        );
    }
  }
  _resolveTask(data) {
    const t = caseConv_default.toCamelCase(data.attributes, {
      map: {
        time_offset: "offset",
        is_queued: "queued"
      }
    });
    t.createdAt = new Date(t.createdAt);
    t.updatedAt &&= new Date(t.updatedAt);
    this.tasks.set(t.id, t);
    return t;
  }
  async execute() {
    await this.client.requests.post(
      endpoints_default2.servers.schedules.exec(this.serverId, this.id)
    );
    this.processing = true;
  }
  async update(options) {
    const data = await this.client.schedules.update(
      this.serverId,
      this.id,
      options
    );
    this._patch(data.toJSON());
    return this;
  }
  async createTask(action, payload, offset, sequenceId) {
    const data = await this.client.requests.post(
      endpoints_default2.servers.schedules.tasks.main(this.serverId, this.id),
      { action, payload, time_offset: offset, sequence_id: sequenceId }
    );
    return this._resolveTask(data);
  }
  async updateTask(id, options) {
    if (!Object.keys(options).length)
      throw new ValidationError(
        "Too few options to update schedule task."
      );
    const payload = caseConv_default.toSnakeCase(options, {
      map: { offset: "time_offset" }
    });
    const data = await this.client.requests.post(
      endpoints_default2.servers.schedules.tasks.get(this.serverId, this.id, id),
      payload
    );
    return this._resolveTask(data);
  }
  async deleteTask(id) {
    await this.client.requests.delete(
      endpoints_default2.servers.schedules.tasks.get(this.serverId, this.id, id)
    );
    this.tasks.delete(id);
  }
  toJSON() {
    const o = caseConv_default.toSnakeCase(this, {
      ignore: ["client", "cron"]
    });
    o.cron = caseConv_default.toSnakeCase(this.cron, {
      map: {
        week: "day_of_week",
        month: "day_of_month"
      }
    });
    return o;
  }
  toString() {
    return this.name;
  }
};
__name(Schedule, "Schedule");

// src/client/ScheduleManager.ts
var ScheduleManager = class {
  constructor(client) {
    this.client = client;
    this.cache = new Dict();
  }
  _patch(id, data) {
    if (data.data) {
      const res = new Dict();
      for (let o of data.data) {
        const s2 = new Schedule(this.client, id, o.attributes);
        res.set(s2.id, s2);
      }
      const hold2 = (this.cache.get(id) || new Dict()).join(res);
      this.cache.set(id, hold2);
      return res;
    }
    const s = new Schedule(this.client, id, data.attributes);
    const hold = (this.cache.get(id) || new Dict()).set(s.id, s);
    this.cache.set(id, hold);
    return s;
  }
  async fetch(server, op1, op2 = {}) {
    let path = endpoints_default2.servers.schedules.main(server);
    if (typeof op1 === "number") {
      if (!op2.force && this.cache.get(server)?.has(op1))
        return this.cache.get(server).get(op1);
      path = endpoints_default2.servers.schedules.get(server, op1);
    } else {
      if (op1)
        op2 = op1;
    }
    const data = await this.client.requests.get(path, op2);
    return this._patch(server, data);
  }
  async create(server, options) {
    options.dayOfWeek ||= "*";
    options.dayOfMonth ||= "*";
    options.onlyWhenOnline ??= false;
    const payload = caseConv_default.toSnakeCase(options, {
      map: { active: "is_active" }
    });
    const data = await this.client.requests.post(
      endpoints_default2.servers.schedules.main(server),
      payload
    );
    return this._patch(server, data);
  }
  async update(server, id, options) {
    if (!Object.keys(options).length)
      throw new ValidationError("Too few options to update schedule.");
    const s = await this.fetch(server, id);
    options.name ||= s.name;
    options.active ||= s.active;
    options.hour ||= s.cron.hour;
    options.minute ||= s.cron.minute;
    options.dayOfWeek ||= s.cron.dayOfWeek;
    options.dayOfMonth ||= s.cron.dayOfMonth;
    options.onlyWhenOnline ??= false;
    const data = await this.client.requests.patch(
      endpoints_default2.servers.schedules.get(server, id),
      caseConv_default.toSnakeCase(options)
    );
    return this._patch(server, data);
  }
  async delete(server, id) {
    await this.client.requests.delete(
      endpoints_default2.servers.schedules.get(server, id)
    );
    this.cache.get(server)?.delete(id);
  }
};
__name(ScheduleManager, "ScheduleManager");

// src/client/ws/Shard.ts
import { EventEmitter as EventEmitter2 } from "events";
import { WebSocket } from "ws";

// src/common/client.ts
var ShardStatus = /* @__PURE__ */ ((ShardStatus2) => {
  ShardStatus2[ShardStatus2["CLOSED"] = 0] = "CLOSED";
  ShardStatus2[ShardStatus2["CONNECTING"] = 1] = "CONNECTING";
  ShardStatus2[ShardStatus2["CONNECTED"] = 2] = "CONNECTED";
  return ShardStatus2;
})(ShardStatus || {});

// src/client/ws/packetHandler.ts
function packetHandler_default(shard, payload) {
  const args = payload.args || [];
  switch (payload.event) {
    case "status":
      shard.emit("statusUpdate", args.join());
      break;
    case "console output":
      shard.emit("serverOutput", args.join());
      break;
    case "daemon message":
      shard.emit("daemonMessage", args.join());
      break;
    case "install started":
      shard.emit("installStart");
      break;
    case "install output":
      shard.emit("installOutput", args.join());
      break;
    case "install completed":
      shard.emit("installComplete");
      break;
    case "stats":
      const stats = JSON.parse(args.join());
      shard.emit("statsUpdate", caseConv_default.toCamelCase(stats));
      break;
    case "transfer logs":
    case "transfer status":
      shard.emit("transferUpdate", args.join());
      break;
    case "backup completed":
      const backup = JSON.parse(args.join());
      shard.emit("backupComplete", caseConv_default.toCamelCase(backup));
      break;
    case "daemon error":
    case "jwt error":
      shard.emit("error", args.join());
      break;
    default:
      shard.emit("error", `received unknown event '${payload.event}'`);
      break;
  }
}
__name(packetHandler_default, "default");

// src/client/ws/Shard.ts
var Shard = class extends EventEmitter2 {
  constructor(client, id, origin) {
    super();
    this.client = client;
    this.id = id;
    this.origin = origin;
    this.socket = null;
    this.status = 0 /* CLOSED */;
    this.readyAt = 0;
    this.ping = -1;
    this.lastPing = 0;
  }
  emit(event, ...args) {
    return super.emit(event, ...args);
  }
  on(event, listener) {
    super.on(event, listener);
    return this;
  }
  once(event, listener) {
    super.once(event, listener);
    return this;
  }
  off(event, listener) {
    super.off(event, listener);
    return this;
  }
  debug(message) {
    super.emit("debug", `[Shard ${this.id}] ${message}`);
  }
  async connect() {
    if (![0, 1].includes(this.status))
      return;
    this.status = 1 /* CONNECTING */;
    const auth = await this.client.ws.getAuth(this.id);
    const origin = this.origin ? { origin: this.client.domain } : void 0;
    this.socket = new WebSocket(auth.data.socket, origin);
    this.socket.on("open", () => this.onOpen(auth.data.token));
    this.socket.on("message", (m) => this.onMessage(m.toString()));
    this.socket.on("error", (e) => this.onError(e));
    this.socket.on("close", () => this.onClose());
  }
  async refresh() {
    if (this.status !== 2 /* CONNECTED */)
      throw new Error("Shard is not connected.");
    const auth = await this.client.ws.getAuth(this.id);
    this.send("auth", [auth.data.token]);
  }
  send(event, args = []) {
    if (!this.socket)
      throw new Error("Socket for this shard is unavailable.");
    this.debug(`sending event '${event}'`);
    this.socket.send(JSON.stringify({ event, args }));
  }
  async request(event, args = "") {
    switch (event) {
      case "auth": {
        this.send("auth", [args]);
        return new Promise((res) => this.once("authSuccess", res));
      }
      case "sendCommand": {
        this.send("send command", [args]);
        return Promise.resolve();
      }
      case "sendLogs": {
        this.send("send logs");
        return new Promise((res) => this.once("serverOutput", res));
      }
      case "sendStats": {
        this.send("send stats");
        return new Promise((res) => this.once("statsUpdate", res));
      }
      case "setState": {
        this.send("set state", [args]);
        return new Promise((res) => this.once("statusUpdate", res));
      }
      default:
        throw new WebSocketError("Invalid sendable websocket event");
    }
  }
  disconnect() {
    this.socket?.close(1e3);
    this.socket = null;
    this.readyAt = 0;
    this.ping = -1;
    this.lastPing = -1;
  }
  onOpen(token) {
    this.status = 2 /* CONNECTED */;
    this.readyAt = Date.now();
    this.send("auth", [token]);
    this.debug("connection opened");
    super.emit("serverConnect", this.id);
    process.on("SIGINT", () => this.disconnect());
    process.on("SIGTERM", () => this.disconnect());
  }
  async onMessage(packet) {
    if (!packet)
      return this.debug("received a malformed packet");
    const data = JSON.parse(packet);
    super.emit("rawPayload", data);
    switch (data.event) {
      case "auth success":
        this.ping = Date.now() - this.lastPing;
        this.lastPing = Date.now();
        super.emit("authSuccess");
        break;
      case "token expiring":
        this.debug("refreshing token");
        await this.refresh();
        break;
      case "token expired":
        this.disconnect();
        break;
      default:
        packetHandler_default(this, data);
        break;
    }
  }
  onError(err) {
    this.debug(`received an error: ${err.message}`);
  }
  onClose() {
    this.status = 0 /* CLOSED */;
    this.debug("connection closed");
    super.emit("serverDisconnect");
  }
};
__name(Shard, "Shard");

// src/client/ws/WebSocketManager.ts
var WebSocketManager = class {
  constructor(client) {
    this.client = client;
    this.shards = /* @__PURE__ */ new Map();
    this.active = false;
    this.useOrigin = false;
  }
  createShard(id) {
    if (this.shards.has(id))
      return this.shards.get(id);
    const shard = new Shard(this.client, id, this.useOrigin);
    this.shards.set(id, shard);
    this.active = true;
    return shard;
  }
  deleteShard(id) {
    if (!this.shards.has(id))
      return false;
    this.shards.get(id).disconnect();
    this.active = !!this.shards.size;
    return this.shards.delete(id);
  }
  get ping() {
    if (!this.shards.size)
      return -1;
    let sum = 0;
    for (let s of this.shards.values())
      sum += s.ping;
    return sum / this.shards.size;
  }
  getAuth(id) {
    return this.client.requests.get(endpoints_default2.servers.ws(id));
  }
  async broadcast(event, args) {
    const res = [];
    for (const shard of this.shards.values()) {
      let data = await shard.request(event, args);
      res.push(data);
    }
    return res;
  }
  destroy() {
    for (let s of this.shards.values())
      s.disconnect();
    this.shards.clear();
    this.active = false;
  }
};
__name(WebSocketManager, "WebSocketManager");

// src/client/index.ts
var PteroClient = class {
  constructor(domain, auth, options = {}) {
    if (!/https?\:\/\/(?:localhost\:\d{4}|[\w\.\-]{3,256})/gi.test(domain))
      throw new ValidationError(
        "Domain URL must start with 'http://' or 'https://' and must be bound to a port if using localhost."
      );
    if (domain.endsWith("/"))
      domain = domain.slice(0, -1);
    this.domain = domain;
    this.auth = auth;
    this.options = config_default.clientConfig({ client: options });
    this.account = new Account(this);
    this.schedules = new ScheduleManager(this);
    this.servers = new ClientServerManager(this);
    this.requests = new RequestManager("Client", domain, auth);
    this.ws = new WebSocketManager(this);
  }
  get ping() {
    return this.requests._ping;
  }
  async fetchPermissions() {
    const data = await this.requests.get(endpoints_default2.permissions);
    return data.attributes.permissions;
  }
  async connect() {
    if (this.options.fetchClient)
      await this.account.fetch();
    if (this.options.servers.fetch && this.options.servers.cache)
      await this.servers.fetch();
  }
  addSocketServer(...args) {
    if (args.length === 1)
      return this.ws.createShard(args[0]);
    return args.map((i) => this.ws.createShard(i));
  }
  removeSocketServer(id) {
    return this.ws.deleteShard(id);
  }
  disconnect() {
    if (this.ws.active)
      this.ws.destroy();
  }
};
__name(PteroClient, "PteroClient");

// src/common/app.ts
var ServerStatus = /* @__PURE__ */ ((ServerStatus2) => {
  ServerStatus2["INSTALLING"] = "installing";
  ServerStatus2["INSTALL_FAILED"] = "install_failed";
  ServerStatus2["SUSPENDED"] = "suspended";
  ServerStatus2["RESTORING"] = "restoring_backup";
  ServerStatus2["NONE"] = "";
  return ServerStatus2;
})(ServerStatus || {});

// src/builders/base.ts
var Builder = class {
  build() {
    return Object.entries(this).reduce((a, b) => {
      a[b[0]] = b[1];
      return a;
    }, {});
  }
};
__name(Builder, "Builder");

// src/builders/Node.ts
var NodeBuilder = class extends Builder {
  constructor() {
    super();
    this.name = "";
    this.description = void 0;
    this.locationId = 0;
    this.public = false;
    this.fqdn = "";
    this.scheme = "";
    this.behindProxy = false;
    this.memory = 0;
    this.memoryOverallocate = -1;
    this.disk = 0;
    this.diskOverallocate = -1;
    this.daemonBase = "/var/lib/pterodactyl/volumes";
    this.daemonSftp = 2022;
    this.daemonListen = 8080;
    this.maintenanceMode = false;
    this.uploadSize = 0;
  }
  setName(name) {
    this.name = name;
    return this;
  }
  setDescription(description) {
    this.description = description;
    return this;
  }
  setLocationId(id) {
    this.locationId = id;
    return this;
  }
  setPublic(value) {
    this.public = value;
    return this;
  }
  setFQDN(fqdn) {
    this.fqdn = fqdn;
    return this;
  }
  setScheme(scheme) {
    this.scheme = scheme;
    return this;
  }
  setBehindProxy(value) {
    this.behindProxy = value;
    return this;
  }
  setMemory(memory, overallocate) {
    this.memory = memory;
    if (overallocate)
      this.memoryOverallocate = overallocate;
    return this;
  }
  setDisk(disk, overallocate) {
    this.disk = disk;
    if (overallocate)
      this.diskOverallocate = overallocate;
    return this;
  }
  setDaemonBase(base) {
    this.daemonBase = base;
    return this;
  }
  setDaemonSFTP(port) {
    this.daemonSftp = port;
    return this;
  }
  setDaemonListen(port) {
    this.daemonListen = port;
    return this;
  }
  setMaintenance(mode) {
    this.maintenanceMode = mode;
    return this;
  }
  setUploadSize(size) {
    this.uploadSize = size;
    return this;
  }
  build() {
    if (!this.name)
      throw new ValidationError("A node name is required");
    if (!this.locationId)
      throw new ValidationError("A location id is required");
    if (!this.fqdn)
      throw new ValidationError("An FQDN is required");
    if (!this.scheme)
      throw new ValidationError("A HTTP scheme is required");
    if (!this.memory)
      throw new ValidationError("A total memory limit is required");
    if (this.memory < 1)
      throw new ValidationError("Memory cannot be less than 1");
    if (this.memoryOverallocate < -1)
      throw new ValidationError(
        "Overallocated memory cannot be less than -1"
      );
    if (!this.disk)
      throw new ValidationError("A total disk limit is required");
    if (this.disk < 1)
      throw new ValidationError("Disk cannot be less than 1");
    if (this.diskOverallocate < -1)
      throw new ValidationError(
        "Overallocated disk cannot be less than -1"
      );
    if (this.uploadSize < 1 || this.uploadSize > 1024)
      throw new ValidationError(
        "The upload size must be between 1 and 1024"
      );
    return super.build();
  }
};
__name(NodeBuilder, "NodeBuilder");

// src/builders/Server.ts
var ServerBuilder = class extends Builder {
  constructor() {
    super();
    this.environment = {};
    this.limits = {
      memory: 128,
      swap: 0,
      disk: 512,
      io: 500,
      cpu: 100,
      threads: null
    };
    this.featureLimits = {
      allocations: 1,
      databases: 1,
      backups: 1
    };
    this.allocation = { default: 0 };
    this.deploy = {
      locations: [],
      dedicatedIp: false,
      portRange: []
    };
  }
  setExternalId(id) {
    this.externalId = id;
    return this;
  }
  setName(name) {
    this.name = name;
    return this;
  }
  setDescription(description) {
    this.description = description;
    return this;
  }
  setUser(user) {
    this.user = typeof user === "number" ? user : user.id;
    return this;
  }
  setEgg(egg) {
    if (typeof egg === "number") {
      this.egg = egg;
    } else {
      this.egg = egg.id;
      this.dockerImage = Object.values(egg.dockerImages)[0];
      this.startup = egg.startup;
    }
    return this;
  }
  setDockerImage(image) {
    this.dockerImage = image;
    return this;
  }
  setStartup(command) {
    this.startup = command;
    return this;
  }
  setVariable(key, value) {
    this.environment[key] = value;
    return this;
  }
  setEnvironment(variables) {
    this.environment = variables;
    return this;
  }
  setSkipScripts(value) {
    this.skipScripts = value;
    return this;
  }
  setOOMDisabled(value) {
    this.oomDisabled = value;
    return this;
  }
  setLimits(limits) {
    this.limits = Object.assign(this.limits, limits);
    return this;
  }
  setFeatureLimits(featureLimits) {
    this.featureLimits = Object.assign(this.featureLimits, featureLimits);
    return this;
  }
  setAllocation(options) {
    if (options.default)
      this.allocation.default = options.default;
    if (options.additional?.length)
      this.allocation.additional = (this.allocation.additional || []).concat(options.additional);
    return this;
  }
  setDeployment(options) {
    if (options.locations?.length)
      this.deploy.locations = (this.deploy.locations || []).concat(
        options.locations
      );
    if (options.dedicatedIp != void 0)
      this.deploy.dedicatedIp = options.dedicatedIp;
    if (options.portRange?.length)
      this.deploy.portRange = (this.deploy.portRange || []).concat(
        options.portRange
      );
    return this;
  }
  setStartOnCompletion(value) {
    this.startOnCompletion = value;
    return this;
  }
  build() {
    if (!this.name)
      throw new ValidationError("A server name is required");
    if (!this.user)
      throw new ValidationError("A server owner (user) is required");
    if (!this.egg)
      throw new ValidationError("An egg is required");
    if (!this.dockerImage)
      throw new ValidationError("A docker image is required");
    if (!this.startup)
      throw new ValidationError("A startup command is required");
    if (!this.deploy.locations.length || !this.deploy.portRange.length) {
      if (!this.allocation.default)
        throw new ValidationError(
          "A default allocation or deployment options is required"
        );
    }
    return super.build();
  }
};
__name(ServerBuilder, "ServerBuilder");

// src/builders/User.ts
var UserBuilder = class extends Builder {
  constructor() {
    super();
    this.externalId = void 0;
    this.username = "";
    this.email = "";
    this.firstname = "";
    this.lastname = "";
    this.password = void 0;
    this.isAdmin = false;
  }
  static fromUser(user) {
    let b = new this();
    if (user.externalId)
      b.setExternalId(user.externalId);
    if (user.username)
      b.setUsername(user.username);
    if (user.email)
      b.setEmail(user.email);
    if (user.firstname)
      b.setFirstname(user.firstname);
    if (user.lastname)
      b.setLastname(user.lastname);
    if (user.isAdmin)
      b.setAdmin(user.isAdmin);
    return b;
  }
  setExternalId(id) {
    this.externalId = id;
    return this;
  }
  setUsername(username) {
    this.username = username;
    return this;
  }
  setEmail(email) {
    this.email = email;
    return this;
  }
  setFirstname(name) {
    this.firstname = name;
    return this;
  }
  setLastname(name) {
    this.lastname = name;
    return this;
  }
  setPassword(password) {
    this.password = password;
    return this;
  }
  setAdmin(state) {
    this.isAdmin = state;
    return this;
  }
  build() {
    if (!this.username)
      throw new ValidationError("a username is required");
    if (!this.email)
      throw new ValidationError("an email is required");
    if (!this.firstname)
      throw new ValidationError("a first name is required");
    if (!this.lastname)
      throw new ValidationError("a last name is required");
    return super.build();
  }
};
__name(UserBuilder, "UserBuilder");

// src/util/escape.ts
function escape_default(input) {
  return input.replace(
    /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g,
    ""
  );
}
__name(escape_default, "default");

// src/index.ts
var version2 = version;
export {
  Account,
  ApplicationDatabaseManager,
  ApplicationServer,
  ApplicationServerManager,
  BackupManager,
  BaseManager,
  BaseUser,
  Builder,
  ClientDatabaseManager,
  ClientServer,
  ClientServerManager,
  Dict,
  FileManager,
  Flags,
  NestEggsManager,
  NestManager,
  NetworkManager,
  Node,
  NodeAllocationManager,
  NodeBuilder,
  NodeLocationManager,
  NodeManager,
  Permissions,
  PteroAPIError,
  PteroApp,
  PteroClient,
  RequestError,
  RequestManager,
  Schedule,
  ScheduleManager,
  ServerBuilder,
  ServerStatus,
  Shard,
  ShardStatus,
  SubUser,
  SubUserManager,
  User,
  UserBuilder,
  UserManager,
  ValidationError,
  WebSocketError,
  WebSocketManager,
  buildQuery,
  caseConv_default as caseConv,
  config_default as configLoader,
  escape_default as escape,
  version2 as version
};
