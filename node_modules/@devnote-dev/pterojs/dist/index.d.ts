import { EventEmitter } from 'events';
import { Axios } from 'axios';

/** Applies an external option to the request. */
declare type External<T> = {
    external?: boolean;
} & T;
/** Applies a filter option to the request. */
declare type Filter<T> = {
    filter?: string;
} & T;
/** An internal form of the filter arguments. */
declare type FilterArray<T> = {
    filter?: string[];
} & T;
/** Applies an include option on the request. */
declare type Include<T> = {
    include?: string[];
} & T;
/** Applies a sort option on the request. */
declare type Sort<T> = {
    sort?: string;
} & T;
/** The types object `T` can be resolved from, including itself. */
declare type Resolvable<T> = string | number | Record<string, any> | T;
/** Represents the daemon information on a node. */
interface DaemonData {
    listening: number;
    sftp: number;
    base: string;
}
/** Represents the feature limits of a server. */
interface FeatureLimits {
    /** The total number of allocations for the server. */
    allocations: number;
    /** The total number of backups allowed on the server. */
    backups: number;
    /** The total number of databases on the server. */
    databases: number;
}
/** General fetch options for requests. */
interface FetchOptions {
    /**
     * Whether to skip cache checks and go straight to the request.
     * This does not apply to all managers that use FetchOptions,
     * check the specific method docs for more information.
     * @default false
     */
    force?: boolean;
    /**
     * The page number to get results from.
     * @default 1
     */
    page?: number;
    /**
     * The number of results to return per-page.
     * @default 50
     */
    perPage?: number;
}
/** Represents the configuration for the pterojs.json file. */
interface FileConfig {
    application?: Record<string, OptionSpec>;
    client?: Record<string, OptionSpec>;
}
/** Represents the limits of a server. */
interface Limits {
    /** The amount of memory allocated to the server. */
    memory: number;
    /** The amount of swap space allocated to the server. */
    swap: number;
    /** The amount of disk allocated to the server. */
    disk: number;
    /** The amount of block IO bandwidth allowed for the server. */
    io: number;
    /**
     * The number of threads (or specific threads) the server can use.
     * `null` means unlimited.
     */
    threads: string | null;
    /** The amount of CPU allocated to the server. */
    cpu: number;
}
/** Represents a location object. */
interface NodeLocation {
    id: number;
    long: string;
    short: string;
    createdAt: Date;
    updatedAt: Date | null;
}
/**
 * Option specification attributes for the {@link FileConfig}.
 * PteroJS currently supports the following config options:
 * * users
 * * nodes
 * * nests
 * * servers
 * * locations
 * * subUsers
 */
interface OptionSpec {
    /**
     * Whether to call the option manager's `fetch()` method
     * (used by the main class' `connect()` method).
     */
    fetch?: boolean;
    /** Whether to cache the option manager's values. */
    cache?: boolean;
    /**
     * The maximum amount of entries to allow for the option manager's cache.
     * @experimental
     */
    max?: number;
}
/**
 * Represents the metadata received from endpoints with
 * paginated responses.
 */
interface PaginationMeta {
    current: number;
    total: number;
    count: number;
    perPage: number;
    totalPages: number;
    links?: string[];
}
interface RequestEvents {
    debug: [message: string];
    preRequest: [data: any];
    postRequest: [data: any];
}

interface DictConstructor {
    new (): Dict<any, any>;
    new <K, V>(entries?: readonly [K, V][]): Dict<K, V>;
    new <K, V>(iterable?: Iterable<readonly [K, V]>): Dict<K, V>;
    readonly [Symbol.iterator]: DictConstructor;
    readonly [Symbol.species]: DictConstructor;
}
/**
 * Dict (or Dictionary) is an extended Map with additional helper methods
 * used for manager caches in the PteroJS library.
 */
declare class Dict<K, V> extends Map<K, V> {
    ['constructor']: DictConstructor;
    private _limit;
    get limit(): number;
    /**
     * Sets a limit for the number of entries the dict can have.
     * **Note:** this cannot be changed once set. Attempting to will throw an error.
     * @param amount The number of entries allowed for the dict.
     */
    setLimit(amount: number): void;
    /** @returns Whether the dict has a set limit. */
    isLimited(): boolean;
    set(key: K, value: V): this;
    /**
     * Checks if at least one of the entries in the dict pass the function.
     * @param fn The function to apply to the dict.
     */
    some(fn: (value: V, key: K, dict: this) => boolean): boolean;
    /**
     * Checks if all the entries in the dict pass the function.
     * @param fn The function to apply to the dict.
     */
    every(fn: (value: V, key: K, dict: this) => boolean): boolean;
    /**
     * Checks that any of the specified keys exist in the dict.
     * @param keys The keys to check for.
     */
    hasAny(...keys: K[]): boolean;
    /**
     * Checks that all of the specified keys exist in the dict.
     * @param keys The keys to check for.
     */
    hasAll(...keys: K[]): boolean;
    /**
     * Returns the first entry (or entries if otherwise specified) in the dict.
     * @param [amount] The number of entries to return from the start of the dict.
     */
    first<T extends number | undefined>(amount?: T): T extends undefined ? V : V[];
    /**
     * Returns the first key (or keys if otherwise specified) in the dict.
     * @param [amount] The number of keys to return from the start of the dict.
     */
    firstKey<T extends number | undefined>(amount?: T): T extends undefined ? K : K[];
    /**
     * Returns the last entry (or entries if otherwise specified) in the dict.
     * @param [amount] The number of entries to return from the end of the dict.
     */
    last<T extends number | undefined>(amount?: T): T extends undefined ? V : V[];
    /**
     * Returns the last key (or keys if otherwise specified) in the dict.
     * @param [amount] The number of keys to return from the end of the dict.
     */
    lastKey<T extends number | undefined>(amount?: T): T extends undefined ? K : K[];
    /**
     * Returns a random entry (or entries if otherwise specified) in the dict.
     * @param [amount] The number of entries to return from the dict.
     */
    random<T extends number | undefined>(amount?: T): T extends undefined ? V : V[];
    /**
     * Returns a random key (or keys if otherwise specified) in the dict.
     * @param [amount] The number of keys to return from the dict.
     */
    randomKey<T extends number | undefined>(amount?: T): T extends undefined ? K : K[];
    /**
     * Applies the function to each entry in the dict and returns an array of
     * the results.
     * @param fn The function to apply to the dict.
     * @returns The mapped results.
     */
    map<T>(fn: (value: V, key: K, dict: this) => T): T[];
    /**
     * Applies the function to each entry in the dict and returns a dict of the
     * results that passed.
     * @param fn The function to apply to the dict.
     * @returns The filtered dict.
     */
    filter(fn: (value: V, key: K, dict: this) => boolean): Dict<K, V>;
    /**
     * Applies a function to each entry in the dict and returns the first one
     * that passes.
     * @param fn The function to apply to the dict.
     */
    find(fn: (value: V, key: K, dict: this) => boolean): V | undefined;
    /**
     * Applies a function to each entry in the dict and returns the number of
     * items removed.
     * @param fn The function to apply to the dict.
     * @returns The number of sweeped entries.
     */
    sweep(fn: (value: V, key: K, dict: this) => boolean): number;
    /**
     * Applies a function to each entry in the dict and returns 2 dicts, the first
     * containing entries that passed the function and the second containing
     * the failed entries.
     * @param fn The function to apply to the dict.
     * @returns The passed and failed dicts.
     */
    part(fn: (value: V, key: K, dict: this) => boolean): Dict<K, V>[];
    /**
     * Reduces each entry in the dict to a single value.
     * @param fn The function to apply to the dict.
     * @returns The reduced value.
     */
    reduce<T>(fn: (value: V, key: K, dict: this) => T, acc: T): T;
    /**
     * Joins one or more dicts with the current one and returns the value.
     * @param dict The dicts to join.
     * @returns The joined dicts.
     */
    join(...dict: Dict<K, V>[]): Dict<K, V>;
    /**
     * @param dict The dict to compare differences to.
     * @returns A dict containing the different entries between both dicts.
     */
    difference(dict: Dict<K, V>): Dict<K, V>;
    /**
     * Updates the values of the current dict with the specified dict, settings the
     * values in place.
     * @param dict The dict to update with.
     */
    update(dict: Dict<K, V>): void;
    /** @returns A clone of the dict. */
    clone(): Dict<K, V>;
}

declare abstract class BaseManager {
    meta: PaginationMeta;
    abstract get FILTERS(): readonly string[];
    abstract get SORTS(): readonly string[];
    abstract get INCLUDES(): readonly string[];
    abstract fetch(...args: unknown[]): Promise<unknown>;
    /**
     * Gets the allowed query options from the inherited manager.
     * @returns The query options.
     * @internal
     */
    getQueryOptions(): {
        filters: readonly string[];
        sorts: readonly string[];
        includes: readonly string[];
    };
    /**
     * Fetches rach page and joins the results.
     * @returns Dictionary of the specified types
     * @internal
     */
    protected getFetchAll<T, K>(...options: unknown[]): Promise<Dict<T, K>>;
}

/** Represents an allocation object. */
interface Allocation {
    id: number;
    ip: string;
    alias: string | undefined;
    port: number;
    notes: string | undefined;
    assigned: boolean;
}
interface ApplicationDatabase {
    id: number;
    serverId: number;
    hostId: number;
    database: unknown;
    username: string;
    remote: string;
    maxConnections: number;
    createdAt: Date;
    updatedAt: Date | undefined;
}
/** Options for creating a node. */
interface CreateNodeOptions {
    name: string;
    description: string | undefined;
    /** @deprecated Broken, use `locationId`. */
    location: string;
    locationId: number;
    public: boolean;
    fqdn: string;
    scheme: string;
    behindProxy: boolean;
    memory: number;
    memoryOverallocate?: number;
    disk: number;
    diskOverallocate?: number;
    /** @deprecated Use `daemonPort` and `daemonListen` instead. */
    sftp: {
        port: number;
        listener: number;
    };
    daemonBase: string;
    daemonSftp: number;
    daemonListen: number;
    maintenanceMode: boolean;
    uploadSize?: number;
}
/** Options for creating a user account. */
interface CreateUserOptions {
    externalId?: string;
    email: string;
    username: string;
    firstname: string;
    lastname: string;
    password?: string;
    isAdmin?: boolean;
}
/** Options for creating a server. */
interface CreateServerOptions {
    /** The external identifier of the server. */
    externalId?: string;
    /** The name of the server. */
    name: string;
    /**
     * A description of the server.
     * @default undefined
     */
    description?: string;
    /** The ID of the user that will own the server. */
    user: number;
    /** The egg to use for the server. */
    egg: number;
    /** The default docker image for the server. */
    dockerImage: string;
    /** The server startup command. */
    startup: string;
    /** An environment variables object. */
    environment: Record<string, string | number | boolean>;
    /**
     * Whether to skip the egg installation script.
     * @default false
     */
    skipScripts?: boolean;
    /** Doesn't work, don't use this. */
    oomDisabled?: boolean;
    /** The server limits. */
    limits?: Partial<Limits>;
    /** The server's feature limits. */
    featureLimits?: Partial<FeatureLimits>;
    /** The server allocation details. */
    allocation: {
        /** The default server allocation. */
        default: number;
        /** Additional allocations for the server. */
        additional?: number[];
    };
    /**
     * Node deployment options. This is for more control over where the
     * server is deployed within the location and port ranges specified.
     */
    deploy?: {
        locations: number[];
        dedicatedIp: boolean;
        portRange: string[];
    };
    /**
     * Whether to start the server after the installation process is complete.
     * @default false
     */
    startOnCompletion?: boolean;
}
/** Represents a nest egg object. */
interface Egg {
    id: number;
    uuid: string;
    nest: number;
    name: string;
    description: string;
    author: string;
    /**
     * @deprecated Will be removed in Pterodactyl v2 in favour of
     * {@link dockerImages}.
     */
    dockerImage: string;
    dockerImages: string[];
    config: {
        files: Record<string, any>;
        startup: Record<string, any>;
        stop: string;
        logs: string[];
        fileDenylist: string[];
        extends: string | null;
    };
    startup: string;
    script: {
        privileged: boolean;
        install: string;
        entry: string;
        container: string;
        extends: string | null;
    };
    createdAt: Date;
    updatedAt: Date | undefined;
}
/** Represents a nest object. */
interface Nest {
    id: number;
    uuid: string;
    author: string;
    name: string;
    description: string;
    createdAt: Date;
    updatedAt: Date | undefined;
}
/** Represents a node configuration object (from Wings). */
interface NodeConfiguration {
    uuid: string;
    tokenId: string;
    token: string;
    debug: boolean;
    api: {
        host: string;
        port: number;
        ssl: {
            enabled: boolean;
            cert: string;
            key: string;
        };
        uploadLimit: number;
    };
    system: {
        data: string;
        sftp: {
            bindPort: number;
        };
    };
    allowedMounts: string[];
    remote: string;
}
/** Query options for fetching deployable nodes. */
interface NodeDeploymentOptions {
    memory: number;
    disk: number;
    locationIds?: number[];
}
/** Represents a server status. If the server has no status, `NONE` is used. */
declare enum ServerStatus {
    INSTALLING = "installing",
    INSTALL_FAILED = "install_failed",
    SUSPENDED = "suspended",
    RESTORING = "restoring_backup",
    NONE = ""
}
interface UpdateBuildOptions {
    limits?: Partial<Limits>;
    featureLimits?: Partial<FeatureLimits>;
    allocation?: number;
    oomDisabled?: boolean;
    addAllocations?: number[];
    removeAllocations?: number[];
}
interface UpdateDetailsOptions {
    name?: string;
    owner?: number;
    externalId?: string;
    description?: string;
}
interface UpdateStartupOptions {
    startup?: string;
    environment?: Record<string, string | number | boolean>;
    egg?: number;
    image?: string;
    skipScripts?: boolean;
}
interface UpdateUserOptions extends Omit<CreateUserOptions, 'externalId'> {
    externalId?: string | null;
}

declare class Node {
    readonly client: PteroApp;
    /** The internal ID of the node (separate from UUID). */
    readonly id: number;
    /** The UUID of the node. */
    readonly uuid: string;
    /** The date the node was created. */
    readonly createdAt: Date;
    /** Whether the node is public. */
    public: boolean;
    /** The name of the node. */
    name: string;
    /** The description of the server (if set). */
    description: string | undefined;
    /** The ID of the location the node is on. */
    locationId: number;
    /**
     * The location object the node is on. This is not fetched by default
     * and must be retrieved by including 'location' in `NodeManager#fetch`.
     */
    location: NodeLocation | undefined;
    /** A dict of servers on the node. */
    servers: Dict<number, ApplicationServer>;
    /** The FQDN of the node. */
    fqdn: string;
    /** The HTTP scheme of the node. */
    scheme: string;
    /** Whether the node is behind a proxy. */
    behindProxy: boolean;
    /** Whether the node is in maintenance mode. */
    maintenance: boolean;
    /** The amount of memory the node has. */
    memory: number;
    /** The amount of memory the node has overallocated. */
    overallocatedMemory: number;
    /** The amount of disk the node has. */
    disk: number;
    /** The amount of disk the node has overallocated. */
    overallocatedDisk: number;
    /** The maximum upload size for the node. */
    uploadSize: number;
    /** The Wings daemon information. */
    daemon: DaemonData;
    constructor(client: PteroApp, data: any);
    _patch(data: any): void;
    /**
     * Returns a formatted URL to the node in the admin panel.
     * @returns The formatted URL.
     */
    get adminURL(): string;
    /**
     * Fetches the configuration of the node.
     * @returns The node configuration.
     */
    getConfig(): Promise<NodeConfiguration>;
    /**
     * Updates the node with the specified options.
     * @param options Update node options.
     * @see {@link CreateNodeOptions UpdateNodeOptions}.
     * @returns The updated instance.
     */
    update(options: Partial<CreateNodeOptions>): Promise<this>;
    /**
     * Converts the node into a JSON object, relative to the API
     * response object.
     * @returns The JSON object.
     */
    toJSON(): object;
    /** @returns The string representation of the node. */
    toString(): string;
}

interface Activity {
    id: string;
    batch: unknown;
    event: string;
    isApi: boolean;
    ip: string | null;
    description: string | null;
    properties: Record<string, any>;
    hasAdditionalMetadata: boolean;
    timestamp: Date;
}
/** Represents a client API key. */
interface APIKey {
    identifier: string;
    description: string;
    allowedIps: string[];
    createdAt: Date;
    lastUsedAt: Date | undefined;
    token?: string;
}
/** Represents a server backup object. */
interface Backup {
    uuid: string;
    name: string;
    ignoredFiles: string[];
    hash: string | undefined;
    bytes: number;
    checksum: string | undefined;
    successful: boolean;
    locked: boolean;
    createdAt: Date;
    completedAt: Date | undefined;
}
/** Represents the client metedata from a client servers request. */
interface ClientMeta {
    isServerOwner?: boolean;
    userPermissions?: Record<string, string>;
}
/** Represents the currently used resources of a server. */
interface ClientResources {
    currentState: string;
    isSuspended: boolean;
    resources: {
        memoryBytes: number;
        cpuAbsolute: number;
        diskBytes: number;
        networkRxBytes: number;
        networkTxBytes: number;
        uptime: number;
    };
}
/** Options for creating a server backup. */
interface CreateBackupOptions {
    name?: string;
    isLocked?: boolean;
    ignored?: string;
}
/** Options for creating a server schedule. */
interface CreateScheduleOptions {
    name: string;
    active: boolean;
    dayOfWeek?: string;
    dayOfMonth?: string;
    month: string;
    hour: string;
    minute: string;
    onlyWhenOnline?: boolean;
}
/** Represents a schedule cronjob object. */
interface Cron {
    dayOfWeek: string;
    dayOfMonth: string;
    month: string;
    hour: string;
    minute: string;
}
/** Represents a server database object. */
interface ClientDatabase {
    id: number;
    name: string;
    username: string;
    host: {
        address: string;
        port: number;
    };
    connectionsFrom: string;
    maxConnections: string;
    password?: string;
}
/** Represents an egg variable. */
interface EggVariable {
    name: string;
    description: string;
    envVariable: string;
    defaultValue: string | number;
    serverValue: string | number;
    isEditable: boolean;
    rules: string;
}
/** Represents a file or file-like object on the server. */
interface File {
    name: string;
    mode: string;
    modeBits: bigint;
    size: number;
    isFile: boolean;
    isSymlink: boolean;
    mimetype: string;
    createdAt: Date;
    modifiedAt: Date | undefined;
}
/** Options for changing file permissions. */
interface FileChmodData {
    file: string;
    mode: number;
}
/** Represents a network allocation object for a server. */
interface NetworkAllocation {
    id: number;
    ip: string;
    ipAlias: string;
    port: number;
    notes: string | null;
    isDefault: boolean;
}
/**
 * Represents a permission descriptor for grouped permissions.
 * Available permission groups:
 * * websocket
 * * control
 * * user
 * * file
 * * backup
 * * allocation
 * * startup
 * * database
 * * schedule
 * * settings
 */
interface PermissionDescriptor {
    description: string;
    keys: Record<string, string>;
}
/** Represents a task for a schedule. */
interface ScheduleTask {
    id: number;
    sequenceId: number;
    action: string;
    payload: string;
    offset: number;
    queued: boolean;
    createdAt: Date;
    updatedAt: Date | undefined;
}
declare type ScheduleTaskAction = 'backup' | 'command' | 'power';
declare enum ShardStatus {
    CLOSED = 0,
    CONNECTING = 1,
    CONNECTED = 2
}
interface SSHKey {
    name: string;
    fingerprint: string;
    publicKey: string;
    createdAt: Date;
}
interface StartupData {
    variables: EggVariable[];
    startupCommand: string;
    dockerImages?: string[];
    rawStartupCommand: string;
}
interface WebSocketAuth {
    data: {
        socket: string;
        token: string;
    };
}
interface WebSocketEvents {
    debug: [message: string];
    error: [message: string];
    rawPayload: [data: any];
    authSuccess: [];
    serverConnect: [id: string];
    serverOutput: [output: string];
    daemonMessage: [output: string];
    serverDisconnect: [];
    statsUpdate: [stats: ClientResources];
    statusUpdate: [status: string];
    transferUpdate: [data: any];
    installStart: [];
    installOutput: [output: string];
    installComplete: [];
    backupComplete: [backup: Partial<Backup>];
}
interface WebSocketPayload {
    event: string;
    args?: string[];
}

declare class Shard extends EventEmitter {
    client: PteroClient;
    id: string;
    origin: boolean;
    private socket;
    private status;
    readyAt: number;
    ping: number;
    lastPing: number;
    constructor(client: PteroClient, id: string, origin: boolean);
    emit<E extends keyof WebSocketEvents>(event: E, ...args: WebSocketEvents[E]): boolean;
    on<E extends keyof WebSocketEvents>(event: E, listener: (...args: WebSocketEvents[E]) => void): this;
    once<E extends keyof WebSocketEvents>(event: E, listener: (...args: WebSocketEvents[E]) => void): this;
    off<E extends keyof WebSocketEvents>(event: E, listener: (...args: WebSocketEvents[E]) => void): this;
    private debug;
    /** Initializes the connection to the server websocket after authentication. */
    connect(): Promise<void>;
    private refresh;
    /**
     * Sends a websocket event to the server (with optional payload args).
     * @param event The event to send to the server.
     * @param args Additional arguements to pass with to the event.
     * @example
     * ```
     * const shard = client.addSocketServer('411d2eb9');
     * shard.on('authSuccess', () => shard.send('send logs'));
     * shard.connect();
     * ```
     */
    send(event: string, args?: string[]): void;
    /**
     * Sends an event to the server and waits for a response.
     * @param event The event to send.
     * @param [args] The arguments to send with the event.
     * @returns The event's response, if any.
     * @example
     * ```
     * const shard = client.addSocketServer('411d2eb9');
     * shard.on('authSuccess', () => {
     *  shard.request('sendCommand', '/say hello world').then(console.log)
     * );
     * shard.connect();
     * ```
     */
    request(event: string, args?: string): Promise<any>;
    /**
     * Sends an event to the server and waits for a response.
     * @param event The event to send.
     * @param command The command to send.
     * @returns The event's response, if any.
     * @example
     * ```
     * const shard = client.addSocketServer('411d2eb9');
     * shard.on('authSuccess', () => {
     *  shard.request('sendCommand', '/say hello world').then(console.log)
     * );
     * shard.connect();
     * ```
     */
    request(event: 'sendCommand', command: string): Promise<void>;
    /**
     * Sends an event to the server and waits for a response.
     * @param event The event to send.
     * @returns The event's response, if any.
     * @example
     * ```
     * const shard = client.addSocketServer('411d2eb9');
     * shard.on('authSuccess', () => {
     *  shard.request('sendLogs').then(console.log)
     * );
     * shard.connect();
     * ```
     */
    request(event: 'sendLogs'): Promise<void>;
    /**
     * Sends an event to the server and waits for a response.
     * @param event The event to send.
     * @returns The event's response, if any.
     * @example
     * ```
     * const shard = client.addSocketServer('411d2eb9');
     * shard.on('authSuccess', () => {
     *  shard.request('sendStats').then(console.log)
     * );
     * shard.connect();
     * ```
     */
    request(event: 'sendStats'): Promise<void>;
    /**
     * Sends an event to the server and waits for a response.
     * @param event The event to send.
     * @param state The power state to send.
     * @returns The event's response, if any.
     * @example
     * ```
     * const shard = client.addSocketServer('411d2eb9');
     * shard.on('authSuccess', () => {
     *  shard.request('setState', 'restart').then(console.log)
     * );
     * shard.connect();
     * ```
     */
    request(event: 'setState', state: string): Promise<void>;
    /** Disconnects the websocket from the API. */
    disconnect(): void;
    private onOpen;
    private onMessage;
    private onError;
    private onClose;
}

declare class BackupManager extends BaseManager {
    client: PteroClient;
    cache: Dict<string, Backup>;
    serverId: string;
    /** Allowed filter arguments for backups (none). */
    get FILTERS(): readonly never[];
    /** Allowed include arguments for backups (none). */
    get INCLUDES(): readonly never[];
    /** Allowed sort arguments for backups (none). */
    get SORTS(): readonly never[];
    constructor(client: PteroClient, serverId: string);
    /**
     * Transforms the raw backup object(s) into typed objects.
     * @param data The resolvable backup object(s).
     * @returns The resolved backup object(s).
     */
    _patch(data: any): any;
    /**
     * Fetches a backup from the API by its identifier. This will check the cache first unless the
     * force option is specified.
     *
     * @param id The identifier of the backup.
     * @param [options] Additional fetch options.
     * @returns The fetched backup.
     * @example
     * ```
     * const server = await client.servers.fetch('34740510');
     * await server.backups.fetch({ perPage: 10 })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetch(id: string, options?: Include<FetchOptions>): Promise<Backup>;
    /**
     * Fetches a list of backups from the API with the given options (default is undefined).
     *
     * @param [options] Additional fetch options.
     * @returns The fetched backups.
     * @example
     * ```
     * const server = await client.servers.fetch('34740510');
     * await server.backups.fetch({ perPage: 10 })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetch(options?: Include<FetchOptions>): Promise<Dict<number, Backup>>;
    /**
     * Creates a new backup on the server.
     * @see {@link CreateBackupOptions}.
     *
     * @param options Create backup options.
     * @returns The new backup.
     * @example
     * ```
     * const server = await client.servers.fetch('34740510');
     * await server.backups.create({ name: 'bungee-archive' })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    create(options?: CreateBackupOptions): Promise<Backup>;
    /**
     * Toggles the locked status of a backup.
     * @param id The UUID of the backup.
     * @returns The updated backup.
     * @example
     * ```
     * const server = await client.servers.fetch('34740510');
     * await server.backups.toggleLock('904df120')
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    toggleLock(id: string): Promise<Backup>;
    /**
     * Fetches the download URL for a specified backup.
     * @param id The UUID of the backup.
     * @returns The download URL.
     * @example
     * ```
     * const server = await client.servers.fetch('34740510');
     * await server.backups.getDownloadURL('904df120')
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    getDownloadURL(id: string): Promise<string>;
    /**
     * Fetches and saves a backup to a specified path on the system.
     * @param id The UUID of the backup.
     * @param dest The file path to save the backup to.
     * @example
     * ```
     * const server = await client.servers.fetch('34740510');
     * await server.backups.download('904df120', './bungee-archive.tar.gz')
     *  .catch(console.error);
     * ```
     */
    download(id: string, dest: string): Promise<void>;
    /**
     * Restores a specified backup to the server.
     * @param id The UUID of the backup.
     * @example
     * ```
     * const server = await client.servers.fetch('34740510');
     * await server.backups.restore('904df120').catch(console.error);
     * ```
     */
    restore(id: string): Promise<void>;
    /**
     * Deletes a specified backup.
     * @param id The UUID of the backup.
     * @example
     * ```
     * const server = await client.servers.fetch('34740510');
     * await server.backups.delete('c4b9c4c7').catch(console.error);
     * ```
     */
    delete(id: string): Promise<void>;
}

declare class ClientDatabaseManager extends BaseManager {
    client: PteroClient;
    cache: Dict<number, ClientDatabase>;
    serverId: string;
    /** Allowed filter arguments for databases (none). */
    get FILTERS(): readonly never[];
    /**
     * Allowed include arguments for databases:
     * * password
     */
    get INCLUDES(): readonly string[];
    /** Allowed sort arguments for databases (none). */
    get SORTS(): readonly never[];
    constructor(client: PteroClient, serverId: string);
    /**
     * Transforms the raw database object(s) into typed objects.
     * @param data The resolvable database object(s).
     * @returns The resolved database object(s).
     */
    _patch(data: any): any;
    /**
     * Fetches a list of databases from the API with the given options (default is undefined).
     *
     * @param [options] Additional fetch options.
     * @returns The fetched databases.
     * @example
     * ```
     * const server = await client.servers.fetch('1c639a86');
     * await server.databases.fetch({ page: 2 })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetch(options?: Include<FetchOptions>): Promise<Dict<number, ClientDatabase>>;
    /**
     * Creates a database on the server.
     * @param database The name of the database.
     * @param remote The connections allowed to the database.
     * @returns The new database.
     */
    create(database: string, remote: string): Promise<ClientDatabase>;
    /**
     * Rotates the password of a specified database.
     * @param id The ID of the database.
     * @returns The updated database.
     * @example
     * ```
     * const server = await client.servers.fetch('1c639a86');
     * await server.databases.rotate(1)
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    rotate(id: number): Promise<ClientDatabase>;
    /**
     * Deletes a database from the server.
     * @param id The ID of the database.
     * @example
     * ```
     * const server = await client.servers.fetch('1c639a86');
     * await server.databases.delete(2).catch(console.error);
     * ```
     */
    delete(id: number): Promise<void>;
}

declare class FileManager {
    client: PteroClient;
    cache: Dict<string, Dict<string, File>>;
    serverId: string;
    constructor(client: PteroClient, serverId: string);
    /**
     * Transforms the raw file object(s) into typed objects.
     * @param data The resolvable file object(s).
     * @returns The resolved file object(s).
     */
    _patch(dir: string, data: any): Dict<string, File>;
    /**
     * Returns a URI-encoded UNIX version of the specified path for requests.
     * @param path The path to clean.
     * @returns The cleaned path.
     */
    private clean;
    /**
     * Fetches the files/directories in a specified direcory (defaults to root).
     * @param [dir] The directory to fetch from.
     * @returns The fetched files.
     * @example
     * ```
     * const server = await client.servers.fetch('aea005b6');
     * await server.files.fetch().then(console.log).catch(console.error);
     * ```
     */
    fetch(dir?: string): Promise<Dict<string, File>>;
    /**
     * Fetches the contents of a specified file. The content is always returned as a
     * string by default, regardless of file type.
     * @param path The file path.
     * @returns The file contents.
     * @example
     * ```
     * const server = await client.servers.fetch('aea005b6');
     * await server.files.getContents('./install.log')
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    getContents(path: string): Promise<string>;
    /**
     * Fetches the download URL for a specified file.
     * @param path The file path.
     * @returns The download URL.
     * @example
     * ```
     * const server = await client.servers.fetch('aea005b6');
     * await server.files.getDownloadURL('./config.yml')
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    getDownloadURL(path: string): Promise<string>;
    /**
     * Fetches and saves a file to a specified path on the system.
     * @param path The file path.
     * @param dest The file path to save the file to.
     * @example
     * ```
     * const server = await client.servers.fetch('aea005b6');
     * await server.files.download('./config.yml', '/mc/config.yml')
     *  .catch(console.error);
     * ```
     */
    download(path: string, dest: string): Promise<void>;
    /**
     * Fetches the upload URL for a specified directory (defaults to root).
     * @param [dir] The directory the files should be uploaded to.
     * @returns The upload URL.
     * @example
     * ```
     * const server = await client.servers.fetch('aea005b6');
     * await server.files.getUploadURL('./plugins')
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    getUploadURL(dir?: string): Promise<string>;
    /**
     * Uploads a file from the system to a specified directory on the server.
     * @param dir The directory the files should be uploaded to.
     * @param file The path to the file on the system.
     * @todo
     */
    private upload;
    /**
     * Writes the content to a specified file.
     * @param path The file path.
     * @param content The content to write.
     * @example
     * ```
     * const server = await client.servers.fetch('aea005b6');
     * await server.files.write(
     *  './config.yml',
     *  'listeners:\n- host: 0.0.0.0:6203\n query_port: 6203'
     * )
     *  .catch(console.error);
     * ```
     */
    write(path: string, content: any): Promise<void>;
    /**
     * Creates a folder in a specified root folder.
     * @param path The root path to create the directory in.
     * @param name The name of the directory.
     * @example
     * ```
     * const server = await client.servers.fetch('aea005b6');
     * await server.files.createFolder('./', 'ext').catch(console.error);
     * ```
     */
    createFolder(path: string, name: string): Promise<void>;
    /**
     * Renames one or more files in a specified directory.
     * @param path The root path of the files.
     * @param files The file rename descriptors.
     * @example
     * ```
     * const server = await client.servers.fetch('aea005b6');
     * await server.files.rename(
     *  './',
     *  [
     *   { from: 'install.log', to: 'old-install.log' },
     *   { from: '_config.yml', to: 'new-config.yml' }
     *  ]
     * )
     *  .catch(console.error);
     * ```
     */
    rename(path: string, files: {
        from: string;
        to: string;
    }[]): Promise<void>;
    /**
     * Changes the permissions on one or more files in a specified directory.
     * @param dir The root path of the files.
     * @param files The file mode descriptors.
     * @example
     * ```
     * const server = await client.servers.fetch('aea005b6');
     * await server.files.chmod(
     *  './',
     *  [{ file: 'server.jar', mode: 0o755 }]
     * )
     *  .catch(console.error);
     * ```
     */
    chmod(dir: string, files: FileChmodData[]): Promise<void>;
    /**
     * Copies the specified file in its directory.
     * @param path The path of the file to copy.
     * @example
     * ```
     * const server = await client.servers.fetch('aea005b6');
     * await server.files.copy('server.properties').catch(console.error);
     * ```
     */
    copy(path: string): Promise<void>;
    /**
     * Compresses the specified files into a zip file.
     * @param dir The root directory of the files.
     * @param files The files to be compressed.
     * @returns The compressed files.
     * @example
     * ```
     * const server = await client.servers.fetch('aea005b6');
     * await server.files.compress(
     *  './'
     *  ['server.properties', 'server.jar', 'config.yml']
     * )
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    compress(dir: string, files: string[]): Promise<File>;
    /**
     * Decompresses the specified file in its directory.
     * @param dir The root directory of the file.
     * @param file The file to decompress.
     * @example
     * ```
     * const server = await client.servers.fetch('aea005b6');
     * await server.files.decompress('./ext', 'archive-2022-08-25T034234Z.tar.gz')
     *  .catch(console.error);
     * ```
     */
    decompress(dir: string, file: string): Promise<void>;
    /**
     * Deletes one or more files in the specified directory.
     * @param dir The root directory of the files.
     * @param files The files to delete.
     * @example
     * ```
     * const server = await client.servers.fetch('aea005b6');
     * await server.files.delete('./', ['old-install.log'])
     *  .catch(console.error);
     * ```
     */
    delete(dir: string, files: string[]): Promise<void>;
}

declare class NetworkManager {
    client: PteroClient;
    cache: Dict<number, NetworkAllocation>;
    serverId: string;
    constructor(client: PteroClient, serverId: string);
    /**
     * Transforms the raw allocation object(s) into typed objects.
     * @param data The resolvable allocation object(s).
     * @returns The resolved allocation object(s).
     */
    _patch(data: any): any;
    /**
     * Fetches the network allocations on the server.
     * @returns The fetched network allocations.
     * @example
     * ```
     * const server = await client.servers.fetch('1c639a86');
     * await server.network.fetch()
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetch(): Promise<Dict<number, NetworkAllocation>>;
    /**
     * Sets the notes of a specified network allocation.
     * @param id The ID of the network allocation.
     * @param notes The notes to set.
     * @returns The updated network allocation.
     * @example
     * ```
     * const server = await client.servers.fetch('1c639a86');
     * await server.network.setNote(14, 'bungee')
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    setNote(id: number, notes: string): Promise<NetworkAllocation>;
    /**
     * Sets the primary allocation of the server.
     * @param id The ID of the network allocation.
     * @returns The updated network allocation.
     * @example
     * ```
     * const server = await client.servers.fetch('1c639a86');
     * await server.network.setPrimary(14)
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    setPrimary(id: number): Promise<NetworkAllocation>;
    /**
     * Unassigns the specified network allocation form the server.
     * @param id The ID of the network allocation.
     * @example
     * ```
     * const server = await client.servers.fetch('1c639a86');
     * await server.network.unassign(12).catch(console.error);
     * ```
     */
    unassign(id: number): Promise<void>;
}

declare class SubUserManager {
    client: PteroClient;
    serverId: string;
    cache: Dict<string, SubUser>;
    constructor(client: PteroClient, serverId: string);
    /**
     * Transforms the raw subuser object(s) into class objects.
     * @param data The resolvable subuser object(s).
     * @returns The resolved subuser object(s).
     */
    _patch(data: any): any;
    /**
     * Resolves a subuser from an object. This can be:
     * * a string
     * * a number
     * * an object
     *
     * @param obj The object to resolve from.
     * @returns The resolved user or undefined if not found.
     */
    resolve(obj: Resolvable<SubUser>): SubUser | undefined;
    /**
     * Returns a formatted URL to the subuser.
     * @returns The formatted URL.
     */
    get panelURL(): string;
    /**
     * Fetches a subuser from the API by its UUID. This will check the cache first unless the
     * force option is specified.
     *
     * @param uuid The UUID of the subuser.
     * @param [options] Additional fetch options.
     * @returns The fetched subuser.
     * @example
     * ```
     * const server = await client.servers.fetch('1c639a86');
     * await server.users.fetch('36de5ed4-8c37-4bde-a1da-4203115a3e9d')
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetch(uuid: string, options?: FetchOptions): Promise<SubUser>;
    /**
     * Fetches a list of subusers from the API with the given options (default is undefined).
     *
     * @param [options] Additional fetch options.
     * @returns The fetched subusers.
     * @example
     * ```
     * const server = await client.servers.fetch('1c639a86');
     * await server.users.fetch({ perPage: 10 })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetch(options?: FetchOptions): Promise<Dict<number, SubUser>>;
    /**
     * Adds a user as a subuser to the server.
     * @param email The email of the account to add.
     * @param permissions Permissions for the account.
     * @returns The new subuser.
     * @example
     * ```
     * const perms = new Permissions(...Permissions.CONTROL, ...Permissions.FILES);
     * const server = await client.servers.fetch('1c639a86');
     * await server.users.add('user@example.com', perms.value)
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    add(email: string, permissions: string[]): Promise<SubUser>;
    /**
     * Updates the permissions of a specified subuser.
     * @param id The UUID of the subuser.
     * @param permissions The permissions to set.
     * @returns The updated subuser account.
     * @example
     * ```
     * const perms = new Permissions(...Permissions.FILES, ...Permissions.BACKUPS);
     * const server = await client.servers.fetch('1c639a86');
     * await server.users.setPermissions(
     *  '36de5ed4-8c37-4bde-a1da-4203115a3e9d',
     *  perms.value
     * )
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    setPermissions(id: string, permissions: string[]): Promise<SubUser>;
    /**
     * Removes a subuser's access to the server.
     * @param id The UUID of the subuser.
     * @example
     * ```
     * const server = await client.servers.fetch('1c639a86');
     * await server.users.remove('9d7b1d20-6e34-4a3a-abcd-c26ae79dc2bd')
     *  .catch(console.error);
     * ```
     */
    remove(id: string): Promise<void>;
}

declare class ClientServer {
    client: PteroClient;
    /** The UUID of the server. */
    readonly uuid: string;
    /** A substring of the server's UUID. */
    readonly identifier: string;
    /** The internal ID of the server. */
    readonly internalId: number;
    /** The name of the server. */
    name: string;
    /** The description of the server (if set). */
    description: string | undefined;
    /** Whether the client user is the server owner. */
    isOwner: boolean;
    /** The name of the node the server is on. */
    node: string;
    /** An object containing the SFTP details. */
    sftpDetails: {
        ip: string;
        port: number;
    };
    /** An object containing the server limits. */
    limits: Limits;
    /** An object containing the server feature limits. */
    featureLimits: FeatureLimits;
    /** A list of egg features the server uses. */
    eggFeatures: string[] | undefined;
    /** The invocation (or startup command) for the server. */
    invocation: string | null;
    /** The docker image the server uses. */
    dockerImage: string;
    /** The current status of the server. */
    status: string | undefined;
    /** Whether the server is suspended. */
    suspended: boolean;
    /** Whether the server is installing. */
    installing: boolean;
    /** Whether the server is transferring. */
    transferring: boolean;
    backups: BackupManager;
    databases: ClientDatabaseManager;
    files: FileManager;
    network: NetworkManager;
    users: SubUserManager;
    constructor(client: PteroClient, data: any);
    _patch(data: any): void;
    /**
     * Returns a formatted URL to the server.
     * @returns The formatted URL.
     */
    get panelURL(): string;
    /**
     * Fetches the server resources data.
     * @returns The server resources.
     */
    fetchResources(): Promise<ClientResources>;
    /**
     * Fetches the server startup and egg variables data.
     * @returns The startup and egg variable data.
     * @see {@link StartupData}.
     */
    fetchStartup(): Promise<StartupData>;
    /**
     * Sends a command to the server console.
     * @param command The command to send.
     */
    sendCommand(command: string): Promise<void>;
    /**
     * Sets the power state of the server.
     * @param state The power state.
     */
    setPowerState(state: 'start' | 'stop' | 'restart' | 'kill'): Promise<void>;
    /**
     * Updates the server's docker image.
     * @param image The docker image.
     */
    setDockerImage(image: string): Promise<void>;
    /**
     * Updates a specified environment variable on the server. The key must be
     * the environment variable name in capital letters, not the normal
     * variable name.
     * @param key The environment variable key.
     * @param value The value of the environment variable.
     * @returns The updated egg variable.
     */
    setVariable(key: string, value: string): Promise<EggVariable>;
    /**
     * Updates the server's name.
     * @param name The new server name.
     */
    rename(name: string): Promise<void>;
    /** Triggers the reinstall process for the server. */
    reinstall(): Promise<void>;
    /**
     * Converts the server into a JSON object, relative to the API
     * response object.
     * @returns The JSON object.
     */
    toJSON(): object;
    /** @returns The string representation of the server. */
    toString(): string;
}

declare class ClientServerManager extends BaseManager {
    client: PteroClient;
    cache: Dict<string, ClientServer>;
    /** Allowed filter arguments for servers (none). */
    get FILTERS(): readonly never[];
    /**
     * Allowed include arguments for servers:
     * * egg
     * * subusers
     */
    get INCLUDES(): readonly string[];
    /** Allowed sort arguments for servers (none). */
    get SORTS(): readonly never[];
    constructor(client: PteroClient);
    /**
     * Transforms the raw server object(s) into class objects.
     * @param data The resolvable server object(s).
     * @returns The resolved server object(s).
     */
    _patch(data: any): any;
    /**
     * @param id The ID of the server.
     * @returns The formatted URL to the server.
     */
    panelURLFor(id: string): string;
    /**
     * Fetches a server from the API by its identifier. This will check the cache first unless the
     * force option is specified.
     *
     * @param id The identifier of the server.
     * @param [options] Additional fetch options, including the `type` scope of the servers to
     * return (can be 'admin', 'admin-all', or 'owner').
     * @returns The fetched server.
     * @example
     * ```
     * client.servers.fetch('411d2eb9')
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetch(id: string, options?: Include<FetchOptions> & {
        type?: 'admin' | 'admin-all' | 'owner';
    }): Promise<ClientServer>;
    /**
     * Fetches a list of servers from the API with the given options (default is undefined).
     * @see {@link Include} and {@link FetchOptions}.
     *
     * @param [options] Additional fetch options, including the `type` scope of the servers to
     * return (can be 'admin', 'admin-all', or 'owner').
     * @returns The fetched servers.
     * @example
     * ```
     * client.servers.fetch({ perPage: 10 })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetch(options?: Include<FetchOptions> & {
        type?: 'admin' | 'admin-all' | 'owner';
    }): Promise<Dict<number, ClientServer>>;
    /**
     * Fetches the server resources data of a server.
     * @param id The identifier of the server.
     * @returns The server resources.
     * @example
     * ```
     * client.servers.fetchResources('411d2eb9')
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetchResources(id: string): Promise<ClientResources>;
    /**
     * Fetches the server startup and egg variables data.
     * @see {@link StartupData}.
     *
     * @param id The identifier of the server.
     * @returns The startup and egg variable data.
     * @example
     * ```
     * client.servers.fetchStartup('411d2eb9')
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetchStartup(id: string): Promise<StartupData>;
    /**
     * Sends a command to the console of a server. Note that this does not return the output from
     * the command, see {@link WebSocketManager} for more information.
     * @param id The identifier of the server.
     * @param command The command to send.
     * @example
     * ```
     * client.servers.sendCommand('411d2eb9', '/say "hello world"')
     *  .catch(console.error);
     * ```
     */
    sendCommand(id: string, command: string): Promise<void>;
    /**
     * Sets the power state of a server.
     * @param id The identifier of the server.
     * @param state The power state to set.
     * @example
     * ```
     * client.servers.setPowerState('411d2eb9', 'start')
     *  .catch(console.error);
     * ```
     */
    setPowerState(id: string, state: 'start' | 'stop' | 'restart' | 'kill'): Promise<void>;
    /**
     * Updates the docker image of a server.
     * @param id The identifier of the server.
     * @param image The docker image.
     * @example
     * ```
     * client.servers.setDockerImage(
     *  '411d2eb9',
     *  'ghcr.io/pterodactyl/yolks:java_17'
     *  )
     *  .catch(console.error);
     * ```
     */
    setDockerImage(id: string, image: string): Promise<void>;
    /**
     * Updates a specified environment variable on a server. The key must be
     * the environment variable name in capital letters, not the normal
     * variable name.
     * @param id The identifier of the server.
     * @param key The environment variable key.
     * @param value The value of the environment variable.
     * @returns The updated egg variable.
     * @example
     * ```
     * await client.servers
     *     .setVariable('b8f32a45', 'SERVER_JARFILE', 'latest.jar')
     *     .then(console.log);
     * ```
     */
    setVariable(id: string, key: string, value: string): Promise<EggVariable>;
    /**
     * Updates the name of a server.
     * @param id The identifier of the server.
     * @param name The new server name.
     * @example
     * ```
     * client.servers.rename('411d2eb9', 'mc-03')
     *  .catch(console.error);
     * ```
     */
    rename(id: string, name: string): Promise<void>;
    /**
     * Triggers the reinstall process of a server.
     * @param id The identifier of the server.
     * @example
     * ```
     * client.servers.reinstall('411d2eb9').catch(console.error);
     * ```
     */
    reinstall(id: string): Promise<void>;
}

declare type Method = 'GET' | 'POST' | 'PATCH' | 'PUT' | 'DELETE';
declare class RequestManager extends EventEmitter {
    private _type;
    _domain: string;
    _auth: string;
    instance: Axios;
    _ping: number;
    private _start;
    constructor(_type: string, _domain: string, _auth: string);
    emit<E extends keyof RequestEvents>(event: E, ...args: RequestEvents[E]): boolean;
    on<E extends keyof RequestEvents>(event: E, listener: (...args: RequestEvents[E]) => void): this;
    once<E extends keyof RequestEvents>(event: E, listener: (...args: RequestEvents[E]) => void): this;
    off<E extends keyof RequestEvents>(event: E, listener: (...args: RequestEvents[E]) => void): this;
    getHeaders(): Record<string, string>;
    private debug;
    _make(method: Method, path: string, body?: any): Promise<any>;
    raw(method: Method, url: string, body?: any): Promise<any>;
    private handleResponse;
    private handleError;
    get(path: string, params?: FetchOptions, body?: any, cls?: BaseManager): Promise<any>;
    post(path: string, body?: any): Promise<any>;
    patch(path: string, body?: any): Promise<any>;
    put(path: string, body?: any): Promise<any>;
    delete(path: string, body?: any): Promise<void>;
}

declare class Schedule {
    client: PteroClient;
    serverId: string;
    /** The ID of the schedule. */
    readonly id: number;
    /** The date the schedule was created. */
    readonly createdAt: Date;
    /** The name of the schedule. */
    name: string;
    /** The schedule cronjob data. */
    cron: Cron;
    /** Whether the schedule is active. */
    active: boolean;
    /** Whether the schedule is currently being processed. */
    processing: boolean;
    /** Whether the schedule should only run when the server is online. */
    onlyWhenOnline: boolean;
    /** The date the schedule was last updated. */
    updatedAt: Date | undefined;
    /** The date the schedule last ran. */
    lastRunAt: Date | undefined;
    /** The date the scheduls is supposed to run next. */
    nextRunAt: Date;
    /** A dict of tasks that will be executed when the schedule is running. */
    tasks: Dict<number, ScheduleTask>;
    constructor(client: PteroClient, serverId: string, data: any);
    _patch(data: any): void;
    _resolveTask(data: any): ScheduleTask;
    /** Executes the schedule immediately. */
    execute(): Promise<void>;
    /**
     * Updates the schedule with the specified options.
     * @param options Update schedule options.
     * @see {@link CreateScheduleOptions UpdateScheduleOptions}.
     * @returns The updated instance.
     */
    update(options: CreateScheduleOptions): Promise<this>;
    /**
     * Creates a task on the schedule.
     * @param action The action the task will perform.
     * @param payload The task payload.
     * @param offset The execution time offset.
     * @returns The new task.
     */
    createTask(action: ScheduleTaskAction, payload: string, offset: number, sequenceId?: number): Promise<ScheduleTask>;
    /**
     * Updates a specified task in the schedule.
     * @param id The ID of the task.
     * @param options Update task options.
     * @returns The updated task.
     */
    updateTask(id: number, options: {
        action: ScheduleTaskAction;
        payload: string;
        offset: number;
    }): Promise<ScheduleTask>;
    /**
     * Deletes a task from the schedule.
     * @param id The ID of the task.
     */
    deleteTask(id: number): Promise<void>;
    /**
     * Converts the schedule into a JSON object, relative to the API
     * response object.
     * @returns The JSON object.
     */
    toJSON(): object;
    /** @returns The string representation of the schedule. */
    toString(): string;
}

declare class ScheduleManager {
    client: PteroClient;
    cache: Dict<string, Dict<number, Schedule>>;
    constructor(client: PteroClient);
    /**
     * Transforms the raw schedule object(s) into class objects.
     * @param data The resolvable schedule object(s).
     * @returns The resolved schedule object(s).
     */
    _patch(id: string, data: any): any;
    /**
     * Fetches a schedule from the API by its ID. This will check the cache first unless the force
     * option is specified.
     *
     * @param server The identifier of the server.
     * @param id The ID of the schedule.
     * @param [options] Additional fetch options.
     * @returns The fetched schedule.
     * @example
     * ```
     * client.schedules.fetch('411d2eb9', 12)
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetch(server: string, id: number, options?: FetchOptions): Promise<Schedule>;
    /**
     * Fetches a list of schedules from the API with the given options (default is undefined).
     *
     * @param server The identifier of the server.
     * @param [options] Additional fetch options.
     * @returns The fetched schedule.
     * @example
     * ```
     * client.schedules.fetch('411d2eb9', { perPage: 10 })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetch(server: string, options?: FetchOptions): Promise<Dict<number, Schedule>>;
    /**
     * Creates a schedule for a specified server.
     * @see {@link CreateScheduleOptions}.
     *
     * @param server The identifier of the server.
     * @param options Create schedule options.
     * @returns The new schedule.
     * @example
     * ```
     * client.schedules.create(
     *  '411d2eb9',
     *  {
     *   name: 'Weekly backup',
     *   active: false,
     *   month: '1',
     *   hour: '*',
     *   minute: '*'
     *  }
     * )
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    create(server: string, options: CreateScheduleOptions): Promise<Schedule>;
    /**
     * Updates a schedule on the specified server.
     * @see {@link CreateScheduleOptions}.
     *
     * @param server The identifier of the server.
     * @param id The ID of the schedule.
     * @param options Update schedule options.
     * @returns The updated schedule.
     * @example
     * ```
     * client.schedules.update('411d2eb9', 5, { onlyWhenOnline: true })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    update(server: string, id: number, options: Partial<CreateScheduleOptions>): Promise<Schedule>;
    /**
     * Deletes a schedule from a specified server.
     * @param server The identifier of the server.
     * @param id The ID of the schedule.
     * @example
     * ```
     * client.schedules.delete('411d2eb9', 3).catch(console.error);
     * ```
     */
    delete(server: string, id: number): Promise<void>;
}

declare class WebSocketManager {
    client: PteroClient;
    shards: Map<string, Shard>;
    active: boolean;
    useOrigin: boolean;
    constructor(client: PteroClient);
    /**
     * Creates a websocket shard instance for a specified server.
     * @param id The identifier of the server.
     * @returns The server websocket shard.
     */
    createShard(id: string): Shard;
    /**
     * Disconnects a server shard's websocket connection and removes it.
     * If some shards do not return a value, `undefined` will be set in place.
     * @param id The identifier of the server.
     * @returns Whether the websocket shard was disconnected and/or removed.
     */
    deleteShard(id: string): boolean;
    get ping(): number;
    /**
     * Fetches the websocket authentication data for a specified server.
     * @param id The identifier of the server.
     * @returns The websocket authentication data.
     */
    getAuth(id: string): Promise<WebSocketAuth>;
    /**
     * Broadcasts an event to all shards and waits for the responses.
     * @param event The event to broadcast.
     * @param args Arguments to send with the event.
     * @returns A list of the returned values, if any.
     * @example
     * ```
     * const values = await client.ws.broadcast('sendStats');
     * console.log(values.map(s => s.resources.uptime));
     * ```
     */
    broadcast<T>(event: string, args?: string): Promise<T[]>;
    /** Disconnects all active websocket shards and removes them. */
    destroy(): void;
}

/**
 * The base class for the Pterodactyl client API.
 * This operates using a Pterodactyl client API key which can be found
 * at <your.domain.name/account/api>.
 *
 * **Warning:** Keep your API key private at all times. Exposing this can lead
 * to your accond and servers being corrupted, exposed and/or deleted.
 */
declare class PteroClient {
    /**
     * The domain for your Pterodactyl panel. This should be the main URL only
     * (not "/api"). Any additional paths will count as the API path.
     */
    domain: string;
    /**
     * The API key for your Pterodactyl account. This should be kept private at
     * all times.
     */
    auth: string;
    /** @deprecated To be replaced with a better system. */
    options: Record<string, OptionSpec>;
    /**
     * The account class for controlling your panel account, including the email,
     * password, API keys and SSH keys.
     */
    account: Account;
    schedules: ScheduleManager;
    servers: ClientServerManager;
    requests: RequestManager;
    ws: WebSocketManager;
    constructor(domain: string, auth: string, options?: Record<string, OptionSpec>);
    get ping(): number;
    /**
     * Fetches the raw permissions from the API.
     * @see {@link PermissionDescriptor}.
     * @returns The raw permission descriptors.
     */
    fetchPermissions(): Promise<Record<string, PermissionDescriptor>>;
    /** Performs preload requests to Pterodactyl. */
    connect(): Promise<void>;
    /**
     * Creates a websocket shard for a specified server.
     * @param id The identifier of the server.
     * @returns The server websocket shard.
     */
    addSocketServer(id: string): Shard;
    /**
     * Creates websocket shards for the specified servers.
     * @param ids The identifiers of the servers.
     * @returns An array of the server websocket shards.
     */
    addSocketServer(...ids: string[]): Shard[];
    /**
     * Removes a server from websocket connections.
     * @param id The identifier of the server.
     * @returns Whether the shard was removed.
     */
    removeSocketServer(id: string): boolean;
    /** Closes any existing websocket connections. */
    disconnect(): void;
}

/**
 * Represents all the Pterodactyl server permissions as flags.
 */
declare enum Flags {
    WEBSOCKET_CONNECT = "websocket.connect",
    CONTROL_CONSOLE = "control.console",
    CONTROL_START = "control.start",
    CONTROL_STOP = "control.stop",
    CONTROL_RESTART = "control.restart",
    USER_CREATE = "user.create",
    USER_READ = "user.read",
    USER_UPDATE = "user.update",
    USER_DELETE = "user.delete",
    FILE_CREATE = "file.create",
    FILE_READ = "file.read",
    FILE_READ_CONTENT = "file.read-content",
    FILE_UPDATE = "file.update",
    FILE_DELETE = "file.delete",
    FILE_ARCHIVE = "file.archive",
    FILE_SFTP = "file.sftp",
    BACKUP_CREATE = "backup.create",
    BACKUP_READ = "backup.read",
    BACKUP_UPDATE = "backup.update",
    BACKUP_DELETE = "backup.delete",
    ALLOCATION_READ = "allocation.read",
    ALLOCATION_CREATE = "allocation.create",
    ALLOCATION_UPDATE = "allocation.update",
    ALLOCATION_DELETE = "allocation.delete",
    STARTUP_READ = "startup.read",
    STARTUP_UPDATE = "startup.update",
    DATABASE_CREATE = "database.create",
    DATABASE_READ = "database.read",
    DATABASE_UPDATE = "database.update",
    DATABASE_DELETE = "database.delete",
    DATABASE_VIEW_PASSWORD = "database.view_password",
    SCHEDULE_CREATE = "schedule.create",
    SCHEDULE_READ = "schedule.read",
    SCHEDULE_UPDATE = "schedule.update",
    SCHEDULE_DELETE = "schedule.delete",
    SETTINGS_RENAME = "settings.rename",
    SETTINGS_REINSTALL = "settings.reinstall",
    ADMIN_WEBSOCKET_ERRORS = "admin.websocket.errors",
    ADMIN_WEBSOCKET_INSTALL = "admin.websocket.install",
    ADMIN_WEBSOCKET_TRANSFER = "admin.websocket.transfer"
}
declare class Permissions {
    /** @returns All the server control permissions. */
    static get CONTROL(): readonly Flags[];
    /** @returns All of the user/subuser permissions. */
    static get USERS(): readonly Flags[];
    /** @returns All of the server file permissions. */
    static get FILES(): readonly Flags[];
    /** @returns All the server backup permissions. */
    static get BACKUPS(): readonly Flags[];
    /** @returns All the server allocation permissions. */
    static get ALLOCATIONS(): readonly Flags[];
    /** @returns All the server startup permissions. */
    static get STARTUPS(): readonly Flags[];
    /** @returns All the server database permissions. */
    static get DATABASES(): readonly Flags[];
    /** @returns All the server schedule permissions. */
    static get SCHEDULES(): readonly Flags[];
    /** @returns All the server settings permissions. */
    static get SETTINGS(): readonly Flags[];
    /** @returns The admin permissions. */
    static get ADMIN(): readonly Flags[];
    /** The string permission value. */
    value: string[];
    /**
     * @param perms The data to resolve permissions from.
     */
    constructor(...perms: string[]);
    /**
     * Resolves a permissions object from a specified source.
     * @param perms The permissions to resolve.
     * @returns The resolved permissions.
     */
    static resolve(...perms: string[]): string[];
    /**
     * @param perms The permissions to check for.
     * @returns True if the current value has any of the specified permissions.
     */
    hasAny(...perms: string[]): boolean;
    /**
     * @param perms The permissions to check for.
     * @returns True if the current value has all of the specified permissions.
     */
    hasAll(...perms: string[]): boolean;
    /**
     * @returns True if the current value includes administrative permissions.
     */
    isAdmin(): boolean;
    /**
     * Adds the specified permissions to the current value.
     * @param perms The permissions to add.
     * @returns The updated permissions instance.
     */
    add(...perms: string[]): this;
    /**
     * Removes the specified permissions from the current value.
     * @param perms The permissions to remove.
     * @returns The updated permissions instance.
     */
    remove(...perms: string[]): this;
    /**
     * @returns An object with all the permissions having `true` or `false`
     * values if they are currently present.
     */
    serialize(): Record<string, boolean>;
}

declare abstract class BaseUser {
    client: PteroApp | PteroClient;
    /** The internal ID of the user. */
    readonly id: number;
    /** The username of the user. */
    username: string;
    /** The email of the user. */
    email: string;
    /** The firstname of the user. */
    firstname: string;
    /** The lastname of the user. */
    lastname: string;
    /** The language set for the user. */
    language: string;
    constructor(client: PteroApp | PteroClient, data: any);
    _patch(data: any): void;
    /**
     * Converts the user into a JSON object, relative to the API
     * response object.
     * @returns The JSON object.
     */
    toJSON(): object;
    /** @returns The string representation of the user. */
    toString(): string;
}
declare class User extends BaseUser {
    client: PteroApp;
    /** The UUID of the user. */
    readonly uuid: string;
    /** The date the user account was created. */
    readonly createdAt: Date;
    readonly createdTimestamp: number;
    /** The external ID of the user (if set). */
    externalId: string | null;
    /** Whether the user is an admin. */
    isAdmin: boolean;
    /** Whether the user has two-factor authentication enabled. */
    twoFactor: boolean;
    /** A dict of the servers associated with the user. */
    servers: Dict<number, ApplicationServer> | undefined;
    /** The date the user account was last updated. */
    updatedAt: Date | undefined;
    updatedTimestamp: number | undefined;
    constructor(client: PteroApp, data: any);
    _patch(data: any): void;
    /**
     * Returns a formatted URL to the user.
     * @returns The formatted URL.
     */
    get adminURL(): string;
}
declare class SubUser {
    client: PteroClient;
    /** The UUID of the user. */
    readonly uuid: string;
    /** The identifier of the server the subuser belongs to. */
    readonly serverId: string;
    /** The date the subuser account was created. */
    readonly createdAt: Date;
    readonly createdTimestamp: number;
    /** The username of the subuser. */
    username: string;
    /** The email of the subuser. */
    email: string;
    /** The URL of the subuser account image. */
    image: string;
    /** Whether the subuser has two-factor authentication enabled. */
    enabled: boolean;
    /** The permissions the subuser has. */
    permissions: Permissions;
    constructor(client: PteroClient, serverId: string, data: any);
    _patch(data: any): void;
    /**
     * Returns a formatted URL to the subuser.
     * @returns The formatted URL.
     */
    get panelURL(): string;
    /**
     * Updates the permissions of the subuser.
     * @param permissions The permissions to set.
     * @returns The updated subuser instance.
     */
    setPermissions(...permissions: string[]): Promise<this>;
}
declare class Account extends BaseUser {
    client: PteroClient;
    /** The internal ID of the account. */
    id: number;
    /** Whether the account has administrative permissions. */
    isAdmin: boolean;
    /** The two-factor authentication tokens for the account. */
    tokens: string[];
    /** The identifiers of API keys associated with the account. */
    apikeys: APIKey[];
    constructor(client: PteroClient);
    /**
     * Returns a formatted URL to the client account.
     * @returns The formatted URL.
     */
    get panelURL(): string;
    /**
     * Fetches any missing/partial account information.
     * @returns The updated instance.
     */
    fetch(): Promise<this>;
    /**
     * Updates the email for the account.
     * @param email The new email.
     * @param password The password for the account.
     * @returns The updated account instance.
     */
    updateEmail(email: string, password: string): Promise<this>;
    /**
     * Updates the password for the account.
     * Note: the password is **not** stored in the account instance.
     * @param oldPass The account's current password.
     * @param newPass The new password for the account.
     * @returns The updated account instance (no change).
     */
    updatePassword(oldPass: string, newPass: string): Promise<this>;
    /**
     * Fetches the 2FA image URL code.
     * @returns The two-factor image URL code.
     */
    get2FACode(): Promise<string>;
    /**
     * Enables 2FA for the account.
     * @param code The 2FA code.
     * @returns A list of 2FA codes.
     */
    enable2FA(code: string): Promise<string[]>;
    /**
     * Disables 2FA on the account and removes existing authentication tokens.
     * @param password The account password.
     */
    disable2FA(password: string): Promise<void>;
    /** @returns A list of API keys associated with the account. */
    fetchKeys(): Promise<APIKey[]>;
    /**
     * Creates an API key associated with the account.
     * @param description The description (or memo) for the key.
     * @param allowedIps A list of IP addresses that can use this key.
     * @returns The new API key.
     */
    createKey(description: string, allowedIps?: string[]): Promise<APIKey>;
    /**
     * Deletes an API key from the account.
     * @param id The identifier of the key.
     */
    deleteKey(id: string): Promise<void>;
    /** @returns A list of activity logs on the account. */
    fetchActivities(): Promise<Activity[]>;
    /** @returns A list of SSH keys associated with the account. */
    fetchSSHKeys(): Promise<SSHKey[]>;
    /**
     * Creates an SSH key associated with the account.
     * @param name The name of the key.
     * @param publicKey The public key to authorize.
     * @returns The new SSH key.
     */
    createSSHKey(name: string, publicKey: string): Promise<SSHKey>;
    /**
     * Removes an SSH key from the account.
     * @param fingerprint The fingerprint of the SSH key.
     */
    removeSSHKey(fingerprint: string): Promise<void>;
}

declare class ApplicationDatabaseManager extends BaseManager {
    client: PteroApp;
    cache: Dict<number, ApplicationDatabase>;
    serverId: number;
    /** Allowed filter arguments for server databases. */
    get FILTERS(): readonly never[];
    /** Allowed include arguments for server databases. */
    get INCLUDES(): readonly string[];
    /** Allowed sort arguments for server databases. */
    get SORTS(): readonly never[];
    constructor(client: PteroApp, serverId: number);
    _patch(data: any): any;
    fetch(id: number, options?: Include<FetchOptions>): Promise<ApplicationDatabase>;
    fetch(options?: Include<FetchOptions>): Promise<Dict<number, ApplicationDatabase>>;
    create(database: string, remote: string, host: number): Promise<ApplicationDatabase>;
    resetPasword(id: number): Promise<void>;
    delete(id: number): Promise<void>;
}

declare class ApplicationServer {
    client: PteroApp;
    databases: ApplicationDatabaseManager;
    /** The internal ID of the server (separate from UUID). */
    readonly id: number;
    /** The UUID of the server. */
    readonly uuid: string;
    /** A substring of the server's UUID. */
    readonly identifier: string;
    /** The date the server was created. */
    readonly createdAt: Date;
    readonly createdTimestamp: number;
    /** The external ID of the server (if set). */
    externalId: string | undefined;
    /** The name of the server. */
    name: string;
    /** The description of the server (if set). */
    description: string | undefined;
    /** The current processing status of the server. */
    status: string | null;
    /** Whether the server is suspended from action. */
    suspended: boolean;
    /** An object containing the server's limits. */
    limits: Limits;
    /** An object containing the server's feature limits. */
    featureLimits: FeatureLimits;
    /** The ID of the server owner. */
    ownerId: number;
    /**
     * The owner of the server. This is not fetched by default and must be
     * retrieved by including 'user' in ApplicationServerManager#fetch.
     */
    owner: User | undefined;
    /** The ID of the node the server is on. */
    nodeId: number;
    /**
     * The node the server is on. This is not fetched by default and must be
     * retrieved by including 'node' in `ApplicationServerManager#fetch`.
     */
    node: Node | undefined;
    /** The ID of the allocation for the server. */
    allocation: number;
    /** The ID of the nest the server is part of. */
    nest: number;
    /** The ID of the egg the server uses. */
    egg: number;
    container: {
        startupCommand: string;
        image: string;
        installed: boolean;
        environment: Record<string, string>;
    };
    constructor(client: PteroApp, data: any);
    _patch(data: any): void;
    /**
     * Returns a formatted URL to the server.
     * @returns The formatted URL.
     */
    get panelURL(): string;
    /**
     * Returns a formatted URL to the server in the admin panel.
     * @returns The formatted URL.
     */
    get adminURL(): string;
    /**
     * Fetches the User object of the server owner.
     * The user can be accessed via {@link ApplicationServer.owner}.
     * @returns The fetched user.
     */
    fetchOwner(): Promise<User>;
    /**
     * Updates the details of the server.
     * @param options Update details options.
     * @see {@link UpdateDetailsOptions}.
     * @returns The updated instance.
     */
    updateDetails(options: UpdateDetailsOptions): Promise<this>;
    /**
     * Updates the build configuration of the server.
     * @param options Update build options.
     * @returns The updated instance.
     */
    updateBuild(options: UpdateBuildOptions): Promise<this>;
    /**
     * Updates the startup configuration of the server.
     * @param options Update startup options.
     * @see {@link UpdateStartupOptions}.
     * @returns The updated instance.
     */
    updateStartup(options: UpdateStartupOptions): Promise<this>;
    /** Suspends the server. */
    suspend(): Promise<void>;
    /** Unsuspends the server. */
    unsuspend(): Promise<void>;
    /**
     * Triggers the reinstall process for the server.
     * Note: most endpoints will be unavailable until this is complete.
     */
    reinstall(): Promise<void>;
    /**
     * Converts the server into a JSON object, relative to the API
     * response object.
     * @returns The JSON object.
     */
    toJSON(): object;
    /** @returns The string representation of the server. */
    toString(): string;
}

declare class ApplicationServerManager extends BaseManager {
    client: PteroApp;
    cache: Dict<number, ApplicationServer>;
    meta: PaginationMeta;
    /**
     * Allowed filter arguments for servers:
     * * name
     * * uuid
     * * uuidShort
     * * identifier (alias for uuidShort)
     * * externalId
     * * image
     */
    get FILTERS(): readonly string[];
    /**
     * Allowed include arguments for servers:
     * * allocations
     * * user
     * * subusers
     * * nest
     * * egg
     * * variables
     * * location
     * * node
     * * databases
     *
     * Note: not all of these include options have been implemented yet.
     */
    get INCLUDES(): readonly string[];
    /**
     * Allowed sort arguments for servers:
     * * id
     * * -id
     * * uuid
     * * -uuid
     *
     * Negative arguments reverse the sorted results.
     */
    get SORTS(): readonly string[];
    constructor(client: PteroApp);
    get defaultLimits(): Limits;
    get defaultFeatureLimits(): FeatureLimits;
    /**
     * Transforms the raw server object(s) into class objects.
     * @param data The resolvable server object(s).
     * @returns The resolved server object(s).
     */
    _patch(data: any): any;
    /**
     * Resolves a server from an object. This can be:
     * * a string
     * * a number
     * * an object
     *
     * @param obj The object to resolve from.
     * @returns The resolved server or undefined if not found.
     */
    resolve(obj: Resolvable<ApplicationServer>): ApplicationServer | Dict<number, ApplicationServer> | undefined;
    /**
     * @param id The ID of the server.
     * @returns The formatted URL to the server in the admin panel.
     */
    adminURLFor(id: number): string;
    /**
     * @param id The ID of the server.
     * @returns The formatted URL to the server.
     */
    panelURLFor(id: string): string;
    /**
     * Fetches a server from the API by its ID. This will check the cache first unless the force
     * option is specified.
     *
     * @param id The ID of the server.
     * @param [options] Additional fetch options.
     * @returns The fetched server.
     * @example
     * ```
     * app.servers.fetch(12).then(console.log).catch(console.error);
     * ```
     */
    fetch(id: number, options?: Include<FetchOptions>): Promise<ApplicationServer>;
    /**
     * Fetches a server from the API by its external ID. This will check the cache first unless the
     * force option is specified.
     *
     * @param id The external ID of the server.
     * @param [options] Additional fetch options.
     * @returns The fetched server.
     * @example
     * ```
     * app.servers.fetch('minecraft').then(console.log).catch(console.error);
     * ```
     */
    fetch(id: string, options?: Include<FetchOptions>): Promise<ApplicationServer>;
    /**
     * Fetches a list of servers from the API with the given options (default is undefined).
     * @see {@link Include} and {@link FetchOptions}.
     *
     * @param [options] Additional fetch options.
     * @returns The fetched servers.
     * @example
     * ```
     * app.servers.fetch({ page: 2 }).then(console.log).catch(console.error);
     * ```
     */
    fetch(options?: Include<FetchOptions>): Promise<Dict<number, ApplicationServer>>;
    /**
     * Fetches all servers from the API with the given options (default is undefined).
     * @see {@link Include} and {@link FetchOptions}.
     *
     * @param [options] Additional fetch options.
     * @returns The fetched servers.
     * @example
     * ```
     * app.servers.fetchAll().then(console.log).catch(console.error);
     * ```
     */
    fetchAll(options?: Include<Omit<FetchOptions, 'page'>>): Promise<Dict<number, ApplicationServer>>;
    /**
     * Queries the API for servers that match the specified query filters. This fetches from the
     * API directly and does not check the cache. Use cache methods for filtering and sorting.
     *
     * Available query filters:
     * * name
     * * uuid
     * * uuidShort
     * * identifier (alias for uuidShort)
     * * externalId
     * * image
     *
     * Available sort options:
     * * id
     * * -id
     * * uuid
     * * -uuid
     *
     * @param entity The entity to query.
     * @param options The query options to filter by.
     * @returns The queried servers.
     * @example
     * ```
     * app.servers.query('ARK', { filter: 'name', sort: 'id' })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    query(entity: string, options: Filter<Sort<{}>>): Promise<Dict<number, ApplicationServer>>;
    /**
     * Creates a server with the specified options.
     * @see {@link CreateServerOptions}.
     * @param options Create server options.
     * @returns The new server.
     * @example
     * ```
     * app.servers.create({
     *  name: 'ptero bot',
     *  user: 5,
     *  egg: 16,
     *  dockerImage: 'ghcr.io/parkervcp/yolks:nodejs_17',
     *  startup: 'if [ -f /home/container/package.json ];' +
     *   'then /usr/local/bin/npm install; fi;' +
     *   '/usr/local/bin/node /home/container/{{BOT_JS_FILE}}',
     *  environment:{
     *   USER_UPLOAD: false,
     *   AUTO_UPDATE: false,
     *   BOT_JS_FILE: 'index.js'
     *  },
     *  allocation:{
     *   default: 24
     *  }
     * })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    create(options: CreateServerOptions): Promise<ApplicationServer>;
    /**
     * Updates the details of a server.
     * @see {@link UpdateDetailsOptions}.
     * @param id The ID of the server.
     * @param options Update details options.
     * @returns The updated server.
     * @example
     * ```
     * app.servers.updateDetails(12, { externalId: 'mc01' })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    updateDetails(id: number, options: UpdateDetailsOptions): Promise<ApplicationServer>;
    /**
     * Updates the build configuration of a server.
     * @see {@link UpdateBuildOptions}.
     * @param id The ID of the server.
     * @param options Update build options.
     * @returns The updated server.
     * @example
     * ```
     * app.servers.updateBuild(12, {
     *  limits:{
     *   memory: 2048
     *  },
     *  addAllocations:[32]
     * })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    updateBuild(id: number, options: UpdateBuildOptions): Promise<ApplicationServer>;
    /**
     * Updates the startup configuration of a server.
     * @see {@link UpdateStartupOptions}.
     * @param id The ID of the server.
     * @param options Update startup options.
     * @returns The updated server.
     * @example
     * ```
     * app.servers.updateStartup(12, {
     *  image: 'ghcr.io/pterodactyl/yolks:java_17',
     *  skipScripts: false
     * })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    updateStartup(id: number, options: UpdateStartupOptions): Promise<ApplicationServer>;
    /**
     * Suspends a server.
     * @param id The ID of the server.
     * @example
     * ```
     * app.servers.suspend(14).catch(console.error);
     * ```
     */
    suspend(id: number): Promise<void>;
    /**
     * Unsuspends a server.
     * @param id The ID of the server.
     * @example
     * ```
     * app.servers.unsuspend(16).catch(console.error);
     * ```
     */
    unsuspend(id: number): Promise<void>;
    /**
     * Triggers the reinstall process of a server.
     * @param id The ID of the server.
     * @example
     * ```
     * app.servers.reinstall(17).catch(console.error);
     * ```
     */
    reinstall(id: number): Promise<void>;
    /**
     * Deletes a server.
     * @param id The ID of the server.
     * @param [force] Whether to force delete the server.
     * @example
     * ```
     * app.servers.delete(21, true).catch(console.error);
     * ```
     */
    delete(id: number, force?: boolean): Promise<void>;
}

declare class NestEggsManager extends BaseManager {
    client: PteroApp;
    cache: Dict<number, Egg>;
    /** Allowed filter arguments for eggs (none). */
    get FILTERS(): readonly never[];
    /**
     * Allowed include arguments for eggs:
     * * nest
     * * servers
     * * config
     * * script
     * * variables
     */
    get INCLUDES(): readonly string[];
    /** Allowed sort arguments for eggs (none). */
    get SORTS(): readonly never[];
    constructor(client: PteroApp);
    /**
     * Transforms the raw egg object(s) into typed objects.
     * @param data The resolvable egg object(s).
     * @returns The resolved egg object(s).
     */
    _patch(data: any): any;
    /**
     * @param id The ID of the egg.
     * @returns The formatted URL to the egg in the admin panel.
     */
    adminURLFor(id: number): string;
    /**
     * Fetches an egg from the API by its ID. This will check the cache first unless the force
     * option is specified.
     *
     * @param nest The ID of the nest.
     * @param id The ID of the egg.
     * @param [options] Additional fetch options.
     * @returns The fetched egg.
     * @example
     * ```
     * app.nests.eggs.fetch(1, 16).then(console.log).catch(console.error);
     * ```
     */
    fetch(nest: number, id: number, options?: Include<FetchOptions>): Promise<Egg>;
    /**
     * Fetches a list of eggs from the API by its ID. This will check the cache first unless the
     * force option is specified.
     *
     * @param nest The ID of the nest.
     * @param [options] Additional fetch options.
     * @returns The fetched eggs.
     * @example
     * ```
     * app.nests.eggs.fetch(1)
     *  .then(eggs => eggs.forEach(e => console.log(e)))
     *  .catch(console.error);
     * ```
     */
    fetch(nest: number, options?: Include<FetchOptions>): Promise<Dict<number, Egg>>;
}

declare class NestManager extends BaseManager {
    client: PteroApp;
    cache: Dict<number, Nest>;
    meta: PaginationMeta;
    eggs: NestEggsManager;
    /** Allowed filter arguments for nests (none). */
    get FILTERS(): readonly never[];
    /**
     * Allowed include arguments for nests:
     * * eggs
     * * servers
     */
    get INCLUDES(): readonly string[];
    /** Allowed sort arguments for nests (none). */
    get SORTS(): readonly never[];
    constructor(client: PteroApp);
    /**
     * Transforms the raw nest object(s) into typed objects.
     * @param data The resolvable nest object(s).
     * @returns The resolved nest object(s).
     */
    _patch(data: any): any;
    /**
     * @param id The ID of the nest.
     * @returns The formatted URL to the nest in the admin panel.
     */
    adminURLFor(id: number): string;
    /**
     * Fetches a nest from the API with the given options (default is undefined).
     * @param id The ID of the nest.
     * @param [include] Optional include arguments.
     * @returns The fetched nest.
     * @example
     * ```
     * app.nests.fetch(1).then(console.log).catch(console.error);
     * ```
     */
    fetch(id: number, include?: string[]): Promise<Nest>;
    /**
     * Fetches a list of nests from the API with the given options (default is undefined).
     * @param [include] Optional include arguments.
     * @returns The fetched nest.
     * @example
     * ```
     * app.nests.fetch()
     *  .then(nests => nests.forEach(n => console.log(n)))
     *  .catch(console.error);
     * ```
     */
    fetch(include?: string[]): Promise<Dict<number, Nest>>;
}

declare class NodeAllocationManager extends BaseManager {
    client: PteroApp;
    cache: Dict<number, Dict<number, Allocation>>;
    meta: PaginationMeta;
    /** Allowed filter arguments for allocations. */
    get FILTERS(): readonly never[];
    /** Allowed include arguments for allocations. */
    get INCLUDES(): readonly string[];
    /** Allowed sort arguments for allocations. */
    get SORTS(): readonly never[];
    constructor(client: PteroApp);
    _patch(node: number, data: any): any;
    /**
     * @param id The ID of the allocation.
     * @returns The formatted URL to the allocation in the admin panel.
     */
    adminURLFor(id: number): string;
    /**
     * Fetches a list of allocations on a specific node from the API with the given options
     * (default is undefined).
     * @see {@link Include} and {@link FetchOptions}.
     *
     * @param [node] Node id
     * @param [options] Additional fetch options.
     * @returns The fetched allocations.
     * @example
     * ```
     * app.allocations.fetch(4, { page: 3 })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetch(node: number, options?: Include<FetchOptions>): Promise<Dict<number, Allocation>>;
    /**
     * Fetches all allocations on a specific node from the API with the given options (default is undefined).
     * @see {@link Include} and {@link FetchOptions}.
     *
     * @param [node] Node id
     * @param [options] Additional fetch options.
     * @returns The fetched allocations.
     * @example
     * ```
     * app.allocations.fetchAll().then(console.log).catch(console.error);
     * ```
     */
    fetchAll(node: number, options?: Include<Omit<FetchOptions, 'page'>>): Promise<Dict<number, Allocation>>;
    /**
     * Fetches the available allocations on a node and returns a single one.
     * @param node The ID of the node.
     * @param single Whether to return a single allocation.
     * @returns The available allocation(s).
     * @example
     * ```
     * app.allocations.fetchAvailable(4, true)
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetchAvailable(node: number, single: true): Promise<Allocation | undefined>;
    /**
     * Fetches the available allocations on a node.
     * @param node The ID of the node.
     * @param single Whether to return a single allocation.
     * @returns The available allocation(s).
     * @example
     * ```
     * app.allocations.fetchAvailable(4, false)
     *  .then(all => all.forEach(a => console.log(a)))
     *  .catch(console.error);
     * ```
     */
    fetchAvailable(node: number, single: false): Promise<Dict<number, Allocation>>;
    /**
     * Creates a number of allocations based on the ports specified. Note that the created
     * allocations will not be returned due to the number that can be created in a single request,
     * which can cause unwanted issues.
     * @param node The ID of the node.
     * @param ip The IP for the allocation.
     * @param ports A list of ports or port ranges for the allocation.
     * @example
     * ```
     * app.allocations.create(4, '10.0.0.1', ['8000-9000'])
     *  .catch(console.error);
     * ```
     */
    create(node: number, ip: string, ports: string[]): Promise<void>;
    /**
     * Deletes an allocation from a node.
     * @param node The ID of the node.
     * @param id The ID of the allocation.
     * @example
     * ```
     * app.allocations.delete(4, 92).catch(console.error);
     * ```
     */
    delete(node: number, id: number): Promise<void>;
}

declare class NodeLocationManager extends BaseManager {
    client: PteroApp;
    cache: Dict<number, NodeLocation>;
    meta: PaginationMeta;
    /**
     * Allowed filter arguments for locations:
     * * short
     * * long
     */
    get FILTERS(): readonly string[];
    /**
     * Allowed include arguments for locations:
     * * nodes
     * * servers
     */
    get INCLUDES(): readonly string[];
    /** Allowed sort arguments for locations (none). */
    get SORTS(): readonly never[];
    constructor(client: PteroApp);
    /**
     * Transforms the raw location object(s) into typed objects.
     * @param data The resolvable location object(s).
     * @returns The resolved location object(s).
     */
    _patch(data: any): any;
    /**
     * Resolves a location from an object. This can be:
     * * a string
     * * a number
     * * an object
     *
     * @param obj The object to resolve from.
     * @returns The resolved location or undefined if not found.
     */
    resolve(obj: Resolvable<any>): NodeLocation | undefined;
    /**
     * @param id The ID of the location.
     * @returns The formatted URL to the location in the admin panel.
     */
    adminURLFor(id: number): string;
    /**
     * Fetches a location or a list of locations from the Pterodactyl API.
     * @param [id] The ID of the location.
     * @param [options] Additional fetch options.
     * @returns The fetched locations(s).
     */
    /**
     * Fetches a location from the API by its ID. This will check the cache first unless the force
     * option is specified.
     *
     * @param id The ID of the location.
     * @param [options] Additional fetch options.
     * @returns The fetched location.
     * @example
     * ```
     * app.locations.fetch(8).then(console.log).catch(console.error);
     * ```
     */
    fetch(id: number, options?: Include<FetchOptions>): Promise<NodeLocation>;
    /**
     * Fetches a list of locations from the API with the given options (default is undefined).
     * @see {@link Include} and {@link FetchOptions}.
     *
     * @param [options] Additional fetch options.
     * @returns The fetched locations.
     * @example
     * ```
     * app.locations.fetch({ include:['nodes'] })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetch(options?: Include<FetchOptions>): Promise<Dict<number, NodeLocation>>;
    /**
     * Fetches all locations from the API with the given options (default is undefined).
     * @see {@link Include} and {@link FetchOptions}.
     *
     * @param [options] Additional fetch options.
     * @returns The fetched locations.
     * @example
     * ```
     * app.locations.fetchAll({ include:['nodes'] })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetchAll(options?: Include<Omit<FetchOptions, 'page'>>): Promise<Dict<number, NodeLocation>>;
    /**
     * Queries the API for locations that match the specified query filters. This fetches from the
     * API directly and does not check the cache. Use cache methods for filtering and sorting.
     *
     * Available query filters:
     * * short
     * * long
     *
     * @param entity The entity to query.
     * @param options The query options to filter by.
     * @returns The queried locations.
     * @example
     * ```
     * app.locations.query('us', { filter: 'long' })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    query(entity: string, options: Filter<Sort<{}>>): Promise<Dict<number, NodeLocation>>;
    /**
     * Creates a location.
     * @param short The short name for the location (usually the country code).
     * @param long The long name for the location.
     * @returns The new location.
     * @example
     * ```
     * app.locations.create('ca', 'canada')
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    create(short: string, long: string): Promise<NodeLocation>;
    /**
     * Updates a location.
     * @param id The ID of the location.
     * @param options The updated short and/or long name of the location.
     * @returns The updated location.
     * @example
     * ```
     * app.locations.update(10, { long: 'united kingdom' })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    update(id: number, options: {
        short?: string;
        long?: string;
    }): Promise<NodeLocation>;
    /**
     * Deletes a location.
     * @param id The ID of the location.
     * @example
     * ```
     * app.locations.delete(9).catch(console.error);
     * ```
     */
    delete(id: number): Promise<void>;
}

declare class NodeManager extends BaseManager {
    client: PteroApp;
    cache: Dict<number, Node>;
    meta: PaginationMeta;
    /**
     * Allowed filter arguments for nodes:
     * * uuid
     * * name
     * * fqdn
     * * daemonTokenId
     */
    get FILTERS(): readonly string[];
    /**
     * Allowed include arguments for nodes:
     * * allocations
     * * location
     * * servers
     *
     * Note: not all of these include options have been implemented yet.
     */
    get INCLUDES(): readonly string[];
    /**
     * Allowed sort arguments for nodes:
     * * id
     * * uuid
     * * memory
     * * disk
     */
    get SORTS(): readonly string[];
    constructor(client: PteroApp);
    /**
     * Transforms the raw node object(s) into class objects.
     * @param data The resolvable node object(s).
     * @returns The resolved node object(s).
     */
    _patch(data: any): any;
    /**
     * Resolves a node from an object. This can be:
     * * a string
     * * a number
     * * an object
     *
     * @param obj The object to resolve from.
     * @returns The resolved node or undefined if not found.
     */
    resolve(obj: Resolvable<Node>): Node | undefined;
    /**
     * @param id The ID of the node.
     * @returns The formatted URL to the node in the admin panel.
     */
    adminURLFor(id: number): string;
    /**
     * Fetches a node from the API by its ID. This will check the cache first unless the force
     * option is specified.
     *
     * @param id The ID of the node.
     * @param [options] Additional fetch options.
     * @returns The fetched node.
     * @example
     * ```
     * app.nodes.fetch(2).then(console.log).catch(console.error);
     * ```
     */
    fetch(id: number, options?: Include<FetchOptions>): Promise<Node>;
    /**
     * Fetches a list of nodes from the API with the given options (default is undefined).
     * @see {@link Include} and {@link FetchOptions}.
     *
     * @param [options] Additional fetch options.
     * @returns The fetched nodes.
     * @example
     * ```
     * app.nodes.fetch({ include:['servers'] })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetch(options?: Include<FetchOptions>): Promise<Dict<number, Node>>;
    /**
     * Fetches all nodes from the API with the given options (default is undefined).
     * @see {@link Include} and {@link FetchOptions}.
     *
     * @param [options] Additional fetch options.
     * @returns The fetched nodes.
     * @example
     * ```
     * app.nodes.fetchAll({ include:['servers'] })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetchAll(options?: Include<Omit<FetchOptions, 'page'>>): Promise<Dict<number, Node>>;
    /**
     * Fetches the deployable nodes from the API following the specified deployable
     * node options. Note that memory and disk are required for deployment options.
     * @see {@link NodeDeploymentOptions}.
     * @param options Deployable node options.
     * @returns The deployable nodes.
     * @example
     * ```
     * app.nodes.fetchDeployable({ memory: 1024, disk: 4000 })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetchDeployable(options: NodeDeploymentOptions): Promise<Dict<number, Node>>;
    /**
     * Queries the API for nodes that match the specified query filters. This fetches from the
     * API directly and does not check the cache. Use cache methods for filtering and sorting.
     *
     * Available query filters:
     * * uuid
     * * name
     * * fqdn
     * * daemonTokenId
     *
     * Available sort options:
     * * id
     * * uuid
     * * memory
     * * disk
     *
     * @param entity The entity to query.
     * @param options The query options to filter by.
     * @returns The queried nodes.
     * @example
     * ```
     * app.nodes.query('nodes.pterodactyl.test', { filter: 'daemonTokenId' })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    query(entity: string, options: Filter<Sort<{}>>): Promise<Dict<number, Node>>;
    /**
     * Fetches the node configuration.
     * @param id The ID of the node.
     * @returns The node configuration.
     * @example
     * ```
     * app.nodes.getConfig(2).then(console.log).catch(console.error);
     * ```
     */
    getConfig(id: number): Promise<NodeConfiguration>;
    /**
     * Creates a node.
     * @param options Create node options.
     * @see {@link CreateNodeOptions}.
     * @returns The new node.
     * @example
     * ```
     * app.nodes.create({
     *  name: 'node04',
     *  locationId: 2,
     *  public: false,
     *  fqdn: 'n4.nodes.pterodactyl.test',
     *  scheme: 'https',
     *  behindProxy: false,
     *  memory: 1024,
     *  disk: 4000,
     *  daemonSftp: 2022,
     *  daemonListen: 8080,
     *  maintenanceMode: false
     * })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    create(options: CreateNodeOptions): Promise<Node>;
    /**
     * Updates a node with the specified options.
     * @param id The ID of the node.
     * @param options Update node options.
     * @see {@link CreateNodeOptions}.
     * @returns The updated node.
     * @example
     * ```
     * app.nodes.update(4, { maintenanceMode: true })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    update(id: number, options: Partial<CreateNodeOptions>): Promise<Node>;
    /**
     * Deletes a node.
     * Note: there must be no servers on the node for this operation to work.
     * Please ensure this before attempting to delete the node.
     * @param id The ID of the node.
     * @example
     * ```
     * app.nodes.delete(3).catch(console.error);
     * ```
     */
    delete(id: number): Promise<void>;
}

declare class UserManager extends BaseManager {
    client: PteroApp;
    cache: Dict<number, User>;
    meta: PaginationMeta;
    /**
     * Allowed filter arguments for users:
     * * email
     * * uuid
     * * username
     * * externalId
     */
    get FILTERS(): readonly string[];
    /**
     * Allowed include arguments for users:
     * * servers
     */
    get INCLUDES(): readonly string[];
    /**
     * Allowed sort arguments for users:
     * * id
     * * -id
     * * uuid
     * * -uuid
     */
    get SORTS(): readonly string[];
    constructor(client: PteroApp);
    /**
     * Transforms the raw user object(s) into class objects.
     * @param data The resolvable user object(s).
     * @returns The resolved user object(s).
     */
    _patch(data: any): any;
    /**
     * Resolves a user from an object. This can be:
     * * a string
     * * a number
     * * an object
     *
     * @param obj The object to resolve from.
     * @returns The resolved user or undefined if not found.
     */
    resolve(obj: Resolvable<User>): User | undefined;
    /**
     * @param id The ID of the user.
     * @returns The formatted URL to the user in the admin panel.
     */
    adminURLFor(id: number): string;
    /**
     * Fetches a user from the API by its ID. This will check the cache first unless the force
     * option is specified.
     *
     * @param id The ID of the user.
     * @param [options] Additional fetch options.
     * @returns The fetched user.
     * @example
     * ```
     * app.users.fetch(5).then(console.log).catch(console.error);
     * ```
     */
    fetch(id: number, options?: Include<FetchOptions>): Promise<User>;
    /**
     * Fetches a user from the API by its external ID. This will check the cache first unless the
     * force option is specified.
     *
     * @param id The external ID of the user.
     * @param [options] Additional fetch options.
     * @returns The fetched user.
     * @example
     * ```
     * app.users.fetch('admin').then(console.log).catch(console.error);
     * ```
     */
    fetch(id: string, options?: Include<FetchOptions>): Promise<User>;
    /**
     * Fetches a list of users from the API with the given options (default is undefined).
     * @see {@link Include} and {@link FetchOptions}.
     *
     * @param [options] Additional fetch options.
     * @returns The fetched users.
     * @example
     * ```
     * app.users.fetch({ perPage: 20 }).then(console.log).catch(console.error);
     * ```
     */
    fetch(options?: Include<FetchOptions>): Promise<Dict<number, User>>;
    /** @deprecated Use {@link UserManager.fetch}. */
    fetchExternal(id: string, options: Include<FetchOptions>): Promise<User>;
    /**
     * Fetches all users from the API with the given options (default is undefined).
     * @see {@link Include} and {@link FetchOptions}.
     *
     * @param [options] Additional fetch options.
     * @returns The fetched users.
     * @example
     * ```
     * app.users.fetchAll({ perPage: 20 }).then(console.log).catch(console.error);
     * ```
     */
    fetchAll(options?: Include<FetchOptions>): Promise<Dict<number, User>>;
    /**
     * Queries the API for users that match the specified query filters. This fetches from the
     * API directly and does not check the cache. Use cache methods for filtering and sorting.
     *
     * Available query filters:
     * * email
     * * uuid
     * * username
     * * externalId
     *
     * Available sort options:
     * * id
     * * -id
     * * uuid
     * * -uuid
     *
     * @param entity The entity to query.
     * @param options The query options to filter by.
     * @returns The queried users.
     * @example
     * ```
     * app.users.query('d5f506c9', { filter: 'uuid' })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    query(entity: string, options: Filter<Sort<{}>>): Promise<Dict<number, User>>;
    /**
     * Creates a user account.
     * @see {@link CreateUserOptions}.
     * @param options Create user options.
     * @returns The new user.
     * @example
     * ```
     * app.users.create({
     *  email: 'user@example.com',
     *  username: 'example-user',
     *  firstname: 'example',
     *  lastname: 'user',
     *  externalId: 'example1'
     * })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    create(options: CreateUserOptions): Promise<User>;
    /**
     * Updates the user account with the specified options.
     * @see {@link UpdateUserOptions}.
     * @param id The ID of the user.
     * @param options Update user options.
     * @returns The updated user.
     * @example
     * ```
     * app.users.update(7, { externalId: 'admin2', isAdmin: true })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    update(id: number, options: Partial<UpdateUserOptions>): Promise<User>;
    /**
     * Deletes a user account.
     * @param id The ID of the user.
     * @example
     * ```
     * app.users.delete(8).catch(console.error);
     * ```
     */
    delete(id: number): Promise<void>;
}

/**
 * The base class for the Pterodactyl application API.
 * This operates using a Pterodactyl API key which can be found at <your.domain.name/admin/api>
 * or <your.domain.name/account/api> if you are using a client API key.
 *
 * **Warning:** Keep your API key private at all times. Exposing this can lead
 * to your servers, nodes, configurations and more being corrupted and/or deleted.
 */
declare class PteroApp {
    /**
     * The domain for your Pterodactyl panel. This should be the main URL only
     * (not "/api"). Any additional paths will count as the API path.
     */
    domain: string;
    /**
     * The API key for your Pterodactyl panel. This should be kept private at
     * all times. Full access must be granted in the panel for the whole library
     * to be accessible.
     */
    auth: string;
    /** @deprecated To be replaced with a better system. */
    options: Record<string, OptionSpec>;
    allocations: NodeAllocationManager;
    locations: NodeLocationManager;
    nests: NestManager;
    nodes: NodeManager;
    servers: ApplicationServerManager;
    users: UserManager;
    requests: RequestManager;
    constructor(domain: string, auth: string, options?: Record<string, OptionSpec>);
    get ping(): number;
}

/** Represents an API error response object. */
interface APIErrorResponse {
    errors: {
        code: string;
        status: string;
        detail: string;
        meta?: unknown;
    }[];
}
/** Thown when an API error is received (usually 4xx errors). */
declare class PteroAPIError extends Error {
    readonly codes: string[];
    readonly meta: unknown;
    constructor(data: APIErrorResponse);
}
/** Thrown when a non-API error is encountered. */
declare class RequestError extends Error {
}
/** Thown when a validation a method, object or other fails to be validated. */
declare class ValidationError extends Error {
    constructor(message: string);
    constructor(key: string, expected: any, got: any);
}
/** Thrown when a websocket error is encountered. */
declare class WebSocketError extends Error {
}

declare abstract class Builder {
    build(): any;
}

declare class NodeBuilder extends Builder {
    private name;
    private description;
    private locationId;
    private public;
    private fqdn;
    private scheme;
    private behindProxy;
    private memory;
    private memoryOverallocate;
    private disk;
    private diskOverallocate;
    private daemonBase;
    private daemonSftp;
    private daemonListen;
    private maintenanceMode;
    private uploadSize;
    constructor();
    setName(name: string): this;
    setDescription(description: string): this;
    setLocationId(id: number): this;
    setPublic(value: boolean): this;
    setFQDN(fqdn: string): this;
    setScheme(scheme: string): this;
    setBehindProxy(value: boolean): this;
    setMemory(memory: number, overallocate?: number): this;
    setDisk(disk: number, overallocate?: number): this;
    setDaemonBase(base: string): this;
    setDaemonSFTP(port: number): this;
    setDaemonListen(port: number): this;
    setMaintenance(mode: boolean): this;
    setUploadSize(size: number): this;
    build(): CreateNodeOptions;
}

declare class ServerBuilder extends Builder {
    private externalId;
    private name;
    private description;
    private user;
    private egg;
    private dockerImage;
    private startup;
    private environment;
    private skipScripts?;
    private oomDisabled?;
    private limits;
    private featureLimits;
    private allocation?;
    private deploy?;
    private startOnCompletion?;
    constructor();
    setExternalId(id: string | undefined): this;
    setName(name: string): this;
    setDescription(description: string): this;
    setUser(user: number | User): this;
    setEgg(egg: number | Egg): this;
    setDockerImage(image: string): this;
    setStartup(command: string): this;
    setVariable(key: string, value: string | number | boolean): this;
    setEnvironment(variables: Record<string, string | number | boolean>): this;
    setSkipScripts(value: boolean): this;
    setOOMDisabled(value: boolean): this;
    setLimits(limits: Partial<Limits>): this;
    setFeatureLimits(featureLimits: Partial<FeatureLimits>): this;
    setAllocation(options: {
        default?: number;
        additional?: number[];
    }): this;
    setDeployment(options: {
        locations?: number[];
        dedicatedIp?: boolean;
        portRange?: string[];
    }): this;
    setStartOnCompletion(value: boolean): this;
    build(): CreateServerOptions;
}

declare class UserBuilder extends Builder {
    private externalId;
    private username;
    private email;
    private firstname;
    private lastname;
    private password;
    private isAdmin;
    constructor();
    static fromUser(user: User): UserBuilder;
    setExternalId(id: string | undefined): this;
    setUsername(username: string): this;
    setEmail(email: string): this;
    setFirstname(name: string): this;
    setLastname(name: string): this;
    setPassword(password: string | undefined): this;
    setAdmin(state: boolean): this;
    build(): CreateUserOptions;
}

/**
 * Escapes (or removes) all the ASCII color and control codes from the given string. This is useful
 * for cleaning logs from a server webssocket output.
 * @param input The string to escape.
 * @returns The escaped string.
 */
declare function export_default(input: string): string;

interface ConvertOptions {
    ignore?: string[];
    map?: Record<string, string>;
    cast?: Record<string, any>;
}
declare function toCamelCase<T>(obj: any, options?: ConvertOptions): T;
declare function toSnakeCase<T>(obj: any, options?: ConvertOptions): T;
declare const _default$1: {
    toCamelCase: typeof toCamelCase;
    toSnakeCase: typeof toSnakeCase;
};

/** @deprecated To be replaced with a better system. */
declare function parseAs(from: Record<string, any>, to: Record<string, any>): Record<string, any>;
/** @deprecated To be replaced with a better system. */
declare function appConfig(options?: FileConfig): Record<string, OptionSpec>;
/** @deprecated To be replaced with a better system. */
declare function clientConfig(options?: FileConfig): Record<string, OptionSpec | any>;
declare const _default: {
    DEFAULT: {
        APPLICATION: {
            users: {
                fetch: boolean;
                cache: boolean;
                max: number;
            };
            nodes: {
                fetch: boolean;
                cache: boolean;
                max: number;
            };
            nests: {
                fetch: boolean;
                cache: boolean;
                max: number;
            };
            servers: {
                fetch: boolean;
                cache: boolean;
                max: number;
            };
            locations: {
                fetch: boolean;
                cache: boolean;
                max: number;
            };
        };
        CLIENT: {
            ws: boolean;
            fetchClient: boolean;
            servers: {
                fetch: boolean;
                cache: boolean;
                max: number;
            };
            subUsers: {
                fetch: boolean;
                cache: boolean;
                max: number;
            };
            disableEvents: never[];
        };
    };
    parseAs: typeof parseAs;
    appConfig: typeof appConfig;
    clientConfig: typeof clientConfig;
};

interface AllowedQueryOptions {
    filters: readonly string[];
    includes: readonly string[];
    sorts: readonly string[];
}
/**
 * Parses an array of arguments into a Pterodactyl query string.
 * @param args The args to parse into the query.
 * @param allowed Allowed argument guards.
 * @returns The parsed query.
 */
declare const buildQuery: (args: FilterArray<Include<Sort<FetchOptions>>>, allowed: AllowedQueryOptions) => string;

declare const version: string;

export { APIErrorResponse, APIKey, Account, Activity, Allocation, AllowedQueryOptions, ApplicationDatabase, ApplicationDatabaseManager, ApplicationServer, ApplicationServerManager, Backup, BackupManager, BaseManager, BaseUser, Builder, ClientDatabase, ClientDatabaseManager, ClientMeta, ClientResources, ClientServer, ClientServerManager, ConvertOptions, CreateBackupOptions, CreateNodeOptions, CreateScheduleOptions, CreateServerOptions, CreateUserOptions, Cron, DaemonData, Dict, DictConstructor, Egg, EggVariable, External, FeatureLimits, FetchOptions, File, FileChmodData, FileConfig, FileManager, Filter, FilterArray, Flags, Include, Limits, Method, Nest, NestEggsManager, NestManager, NetworkAllocation, NetworkManager, Node, NodeAllocationManager, NodeBuilder, NodeConfiguration, NodeDeploymentOptions, NodeLocation, NodeLocationManager, NodeManager, OptionSpec, PaginationMeta, PermissionDescriptor, Permissions, PteroAPIError, PteroApp, PteroClient, RequestError, RequestEvents, RequestManager, Resolvable, SSHKey, Schedule, ScheduleManager, ScheduleTask, ScheduleTaskAction, ServerBuilder, ServerStatus, Shard, ShardStatus, Sort, StartupData, SubUser, SubUserManager, UpdateBuildOptions, UpdateDetailsOptions, UpdateStartupOptions, UpdateUserOptions, User, UserBuilder, UserManager, ValidationError, WebSocketAuth, WebSocketError, WebSocketEvents, WebSocketManager, WebSocketPayload, buildQuery, _default$1 as caseConv, _default as configLoader, export_default as escape, version };
